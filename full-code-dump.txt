=== ./CLAUDE.md ===
# BEANS Protocol — Frontend

## Overview

Gamified mining protocol on BNB Chain. Users compete in 60-second rounds on a 5×5 grid of blocks, deploying BNB to earn BEANS tokens and BNB rewards. Built with Next.js 14 (App Router), React 18, TypeScript, and Wagmi/RainbowKit for wallet integration.

## Tech Stack

- **Framework:** Next.js 14.2.3 (App Router)
- **UI:** React 18.3.1, TypeScript 5
- **Web3:** Wagmi 2.8.0, Viem 2.9.20, RainbowKit 2.1.2
- **State:** TanStack React Query 5.28.4, useState, custom window events
- **Styling:** Inline React styles (no CSS framework). Dark theme `#0a0a0a`, accent `#F0B90B`

## Project Structure

```
app/
  page.tsx          — Home / Mining interface (LandingPage → MiningGrid)
  about/page.tsx    — Protocol documentation
  global/page.tsx   — Global stats, mining tables, revenue, leaderboard
  stake/page.tsx    — Staking interface
  layout.tsx        — Root layout with Web3Provider
  globals.css       — Global styles

components/
  Header.tsx          — Top nav with BNB/BEAN price feeds, wallet button
  BottomNav.tsx       — Mobile bottom navigation
  LandingPage.tsx     — Landing/intro screen with CTA
  MiningGrid.tsx      — 5×5 interactive block grid
  SidebarControls.tsx — Desktop mining controls (manual/auto modes)
  MobileControls.tsx  — Mobile mining controls
  ClaimRewards.tsx    — Rewards display + claim buttons (BNB, unrefined/refined BEAN)
  MinersPanel.tsx     — Winning miners sliding panel (BNB + BEAN rewards per round)
  MobileMiners.tsx    — Mobile miners panel
  MobileStatsBar.tsx  — Mobile stats bar
  GlobalStats.tsx     — Protocol metrics (supply, burned, revenue)
  MiningTable.tsx     — Mining history table
  RevenueTable.tsx    — Protocol revenue breakdown
  LeaderboardTable.tsx— Top miners/stakers leaderboard
  StakePage.tsx       — Staking deposit/withdraw interface
  WalletButton.tsx    — Wallet connection with balance display
  BeanLogo.tsx        — Logo SVG components
  AboutPage.tsx       — About content with expandable sections

lib/
  api.ts            — Backend API helpers (apiFetch). Base URL via NEXT_PUBLIC_API_URL env var (default http://localhost:3001)
  SSEContext.tsx    — Centralized SSE provider (useSSE hook for subscribeGlobal/subscribeUser)
  contracts.ts      — Contract addresses, ABIs, and constants (MIN_DEPLOY_PER_BLOCK, EXECUTOR_FEE_BPS)
  providers.tsx     — Web3Provider (Wagmi, RainbowKit, React Query, SSEProvider)
  wagmi.ts          — Chain config (BSC mainnet + testnet)
  abis/             — Contract ABI JSON files (GridMining, AutoMiner, Bean, Treasury, ERC20)
```

## Commands

```bash
npm run dev       # Development server
npm run build     # Production build
npm start         # Production server
npm run lint      # Linter
```

## Conventions

- **Styling:** Inline `React.CSSProperties` objects. No Tailwind or CSS-in-JS library.
- **Colors:** Background `#0a0a0a`, accent/yellow `#F0B90B`, text white/gray variants.
- **Responsive:** Mobile breakpoint at `768px`. Separate mobile components (`MobileControls`, `MobileMiners`, `MobileStatsBar`).
- **Cross-component communication:** `window.dispatchEvent` / `window.addEventListener` with custom events.
- **No global state library.** Component-level `useState` and prop drilling.

## Contract Addresses

| Contract    | Address                                      |
|-------------|----------------------------------------------|
| BEANS Token | `0x000Ae314E2A2172a039B26378814C252734f556A` |
| Bean        | `0xBe4764ccE14B7BF478597AA00F5f6A5D42547925` |
| GridMining  | `0x103182b4E9E530ff2e0c69b0CC2a43EE7bb262`   |
| Treasury    | `0x0093DB20543d17F294F58432D08c4FA47C70dfe9` |
| AutoMiner   | `0x89286f7B9aFc0249CbB67fA661a9eB1039fe75dB` |
| BEAN/BNB LP | `0x7e58f160b5b77b8b24cd9900c09a3e730215ac47` |

**ABI source:** `lib/abis/GridMining.json` is extracted from Hardhat artifacts (`hardhat/artifacts/contracts/GridMining.sol/GridMining.json`). Includes `AlreadyDeployedThisRound` custom error, `ResetRequested` event, and `topMinerSeed`/`winnersDeployed` fields in `RoundSettled` event.

## Integration Status

### Connected to Backend + Smart Contract
- **app/page.tsx** — Orchestrates deploy and claim flows. Uses wagmi `useWriteContract` to call `GridMining.deploy(uint8[] blockIds)` payable, `GridMining.claimBNB()`, and `GridMining.claimBEAN()`. On deploy tx success, dispatches `userDeployed` window event for optimistic block tracking. Passes `onDeploy`, `onClaimBNB`, `onClaimBEAN` callbacks to child components.
- **MiningGrid.tsx** — Fetches `GET /api/round/current?user=` on mount (with wallet address when connected), uses `useSSE()` to subscribe to global events (`deployed`, `roundSettled`, `gameStarted`) and user events (`autoMineExecuted`). Dispatches `roundData`, `roundDeployed`, and `roundSettled` window events. Tracks `userDeployedBlocks` (blocks user already deployed to this round) via `GET /api/user/:address/history?type=deploy&roundId=X` on load and optimistic `userDeployed` events. Deployed blocks are visually marked (green border + ✓) and unclickable. **One deploy per round:** `hasDeployedThisRound` boolean locks ALL grid blocks after the first deploy — set `true` on `userDeployed` event or when backend history shows existing deploys, reset to `false` in `resetForNewRound()`. The `selectAllBlocks` listener is also ignored when `hasDeployedThisRound` is true. **AutoMiner grid lock:** When in auto mode (`autoMode.enabled`), all grid cells are disabled to prevent manual selection.
- **SidebarControls.tsx** — Receives round data (beanpot, timer, round number, total deployed, user deployed) via `roundData`/`roundDeployed`/`roundSettled` window events from MiningGrid. Uses `useSSE()` to subscribe to user events (`autoMineExecuted`, `configDeactivated`, `stopped`) for AutoMiner real-time updates. Fetches BNB and BEAN prices from `GET /api/stats` every 30s. Phase (counting/eliminating/winner) driven by backend events, not a local timer. Deploy button enabled only when `canDeploy` (perBlock >= MIN_DEPLOY_PER_BLOCK, blocks > 0, timer > 0, phase === "counting", `userDeployed === 0`). When `hasDeployed` (userDeployed > 0), button shows "✓ Deployed" and is disabled. **Input is per-block amount** — total is calculated as `perBlock × selectedBlocks`.
- **MobileControls.tsx** — Same as SidebarControls but mobile layout. Uses `useSSE()` for user event subscriptions. Phase-aware deploy button with same `canDeploy` logic. Tracks `userDeployed` via `roundData` and `roundDeployed` window events (matches `user` field against connected `userAddress` prop). Shows "✓ Deployed" when locked.
- **MobileStatsBar.tsx** — Receives beanpot, timer, total deployed, and user deployed via `roundData`/`roundDeployed` window events.
- **ClaimRewards.tsx** — Fetches `GET /api/user/:address/rewards` on mount. Re-fetches on `settlementComplete` window event (after 8s animation). Uses `useSSE()` to subscribe to `claimedBNB`/`claimedBEAN` events to refresh after on-chain claim. Shows BNB rewards, unrefined BEAN, refined BEAN separately. Conditionally rendered — hidden when all rewards are zero. Claim buttons call `GridMining.claimBNB()` and `GridMining.claimBEAN()` via wagmi `useWriteContract`.
- **MinersPanel.tsx** — Sliding left panel showing winning miners from the last settled round. Listens to `roundSettled` window event to capture the settled roundId (stored in a ref), then on `settlementComplete` (after 8s animation) fetches `GET /api/round/:id/miners` to get computed BNB and BEAN rewards per winner. Uses a consume-once ref pattern: `settledRoundIdRef` is set by `roundSettled` and cleared after consumption by `settlementComplete`, so empty rounds (no `roundSettled` event) don't re-trigger old data. Panel auto-opens when winners data arrives; collapsed state shows a trophy icon tab on the left edge. If the round had no deployments (empty miners response), keeps showing the previous round's data without re-opening.
- **app/page.tsx** — Also handles AutoMiner contract interactions via `handleAutoActivate` (calls `AutoMiner.setConfig` payable) and `handleAutoStop` (calls `AutoMiner.stop`). Dispatches `autoMinerActivated`/`autoMinerStopped` window events on success.
- **SidebarControls.tsx / MobileControls.tsx** — Support both Manual and Auto mining modes. Auto mode: fetches `GET /api/automine/:address` on mount, uses `useSSE()` to subscribe to `autoMineExecuted`/`configDeactivated`/`stopped` events for real-time updates. When AutoMiner is active, hides Manual tab and shows active status (balance, strategy, rounds executed/total, per block/round). Configure view validates per-block amount against `MIN_DEPLOY_PER_BLOCK` accounting for `EXECUTOR_FEE_BPS` (0.5%). Calls `onAutoActivate`/`onAutoStop` props from page.tsx.
- **MiningGrid.tsx** — Also uses `useSSE()` to subscribe to `autoMineExecuted` to highlight deployed blocks green. Additionally handles AutoMiner deployments in the global `deployed` SSE handler: when `isAutoMine === true` and user matches, fetches deployment history and decodes `blockMask` to mark deployed blocks.
- **MiningTable.tsx** — Fetches `GET /api/rounds?page=N&limit=12&settled=true` on mount. Supports two tabs: "Rounds" (all settled rounds) and "Beanpot" (rounds where motherlode was won, via `&beanpot=true`). Server-side pagination. Displays: Round ID, winning block, BEAN winner (address or "Split" badge based on `isSplit`), winner count, BNB deployed/vaulted/winnings, beanpot amount (or dash if 0), relative time.
- **RevenueTable.tsx** — Fetches `GET /api/treasury/buybacks?page=N&limit=12` on mount. Server-side pagination. Displays buyback transactions: Time (relative), BNB Spent, BEAN Burned, Yield Generated (BEAN to stakers). No tabs — only Buybacks view.
- **LeaderboardTable.tsx** — Fetches `GET /api/leaderboard/miners?period=all&limit=12` and `GET /api/leaderboard/earners?limit=12` on mount. Three tabs: Miners (total BNB deployed), Stakers (coming soon - empty state), Unrefined (unclaimed BEAN). Displays: Rank, Address (truncated), Value with icon (BNB or BEAN).
- **GlobalStats.tsx** — Fetches `GET /api/stats` and `GET /api/treasury/stats` on mount. Displays: Max Supply (hardcoded 3M), Circulating Supply (`totalMintedFormatted`), Burned (`totalBurnedFormatted`), Protocol Revenue (`totalVaultedFormatted`).

### Still Using Mock/Hardcoded Data
- **Header.tsx** — Price feeds from Binance/DexScreener directly.
- **MobileMiners.tsx** — Hardcoded miner list (not yet connected to `/api/round/:id/miners`).
- **StakePage.tsx** — Mock staking data.
- **WalletButton.tsx** — Wallet connection functional, balance reads via wagmi.

### Not Yet Connected
- Smart contract write interactions for staking
- User data endpoints (profile)

## Architecture Notes

### MiningGrid Round Lifecycle

The grid handles three SSE events with careful ordering logic since `roundSettled` and `gameStarted` originate from the same blockchain transaction and can arrive in any order:

1. **`deployed`** — Updates grid cells with aggregated block data from backend. Skipped during settlement animation.
2. **`roundSettled`** — Freezes current grid into a `snapshotCellsRef` (immune to resets), starts 5-second elimination animation, shows winner for 3 seconds, then resets.
3. **`gameStarted`** — Always buffered into `pendingResetRef`, never resets immediately. A 2-second fallback timer handles the case where `roundSettled` was missed.

**Key pattern:** During the 8-second settlement animation, the render reads from `snapshotCellsRef` instead of `cells` state. This ensures the old round's deployment data stays visible even if the cells state is reset by other events. After the animation, `resetForNewRound()` clears the snapshot, resets all state, and re-fetches `/api/round/current?user=` to catch any deployments that arrived during the animation window.

### User Address Prop Threading

The connected wallet address flows from `app/page.tsx` (via `useAccount()`) down to components as `userAddress` prop:

- **MiningGrid** — Uses it to fetch `/api/round/current?user={address}`, which returns `userDeployedFormatted` in the response. This is included in the `roundData` window event. Also keeps a `userAddressRef` so the `resetForNewRound` callback always reads the latest address.
- **SidebarControls / MobileStatsBar** — Use it to match the `user` field in `roundDeployed` events against the connected wallet. When the deployer matches, `userDeployedFormatted` (provided by backend in the SSE `deployed` event) updates the "You deployed" display in real time.

**Stale closure note:** The `useEffect` that registers window event listeners in SidebarControls and MobileStatsBar must include `userAddress` in its dependency array, otherwise the `handleRoundDeployed` callback captures `undefined` from initial render and never matches.

### Custom Window Events

Components communicate via `window.dispatchEvent` / `window.addEventListener`:

| Event | Dispatched By | Consumed By | Payload |
|-------|--------------|-------------|---------|
| `roundData` | MiningGrid | SidebarControls, MobileControls, MobileStatsBar | Full round metadata: `{ roundId, startTime, endTime, motherlodePoolFormatted, totalDeployedFormatted, userDeployedFormatted, ... }` |
| `roundDeployed` | MiningGrid | SidebarControls, MobileControls, MobileStatsBar | Live deployment update: `{ totalDeployed, totalDeployedFormatted, user, userDeployedFormatted }` |
| `roundSettled` | MiningGrid | SidebarControls, MobileControls, MinersPanel | Settlement data: `{ roundId, winningBlock, topMiner, totalWinnings, ... }` |
| `blocksChanged` | MiningGrid | SidebarControls, MobileControls | `{ blocks: number[], count: number }` |
| `selectAllBlocks` | SidebarControls, MobileControls | MiningGrid | `{ selectAll: boolean }` |
| `userDeployed` | app/page.tsx (on tx success) | MiningGrid | `{ blockIds: number[] }` — optimistically marks blocks as deployed |
| `settlementComplete` | MiningGrid | ClaimRewards, MinersPanel | No payload — signals that the 8s settlement animation finished and grid has reset |

### MinersPanel Off-Chain Reward Calculation

The `GET /api/round/:id/miners` endpoint computes per-winner rewards entirely off-chain from MongoDB data:

1. **Filter winners:** Query deployments for the round, filter by `blockMask & (1 << winningBlock) !== 0`
2. **BNB rewards:** `(totalWinnings × userDeployed) / totalWinnersDeployed` — proportional for all rounds
3. **BEAN rewards (split, `isSplit=true`):** `(topMinerReward × userDeployed) / totalWinnersDeployed`
4. **BEAN rewards (non-split, `isSplit=false`):** Weighted random replay:
   - `sample = topMinerSeed % winnersDeployed`
   - Replay deployments to winning block in `blockNumber + logIndex` order
   - Each adds `amountPerBlock` to cumulative; first to exceed `sample` is BEAN winner
   - Winner gets full `topMinerReward`; others get 0 BEAN
5. **Motherlode:** `(motherlodeAmount × userDeployed) / totalWinnersDeployed` — added to all winners

`topMinerSeed` and `winnersDeployed` are emitted in the `RoundSettled` contract event and stored in the Round model. Deployment ordering relies on `blockNumber` + `logIndex` fields stored in the Deployment model (populated from QuickNode stream filter).

### One Deploy Per Round

The GridMining contract enforces one deploy per round per user — calling `deploy()` a second time in the same round reverts with `AlreadyDeployedThisRound`. The frontend mirrors this constraint:

1. **MiningGrid** — `hasDeployedThisRound` state (boolean). Set `true` when `userDeployed` window event fires (optimistic, on tx success) or when backend history shows `userDeployedBlocks.size > 0`. All grid cells become `disabled` when true. `selectAllBlocks` events are ignored. On `userDeployed`, selected blocks are cleared and `blocksChanged` is dispatched with empty blocks. Reset to `false` in `resetForNewRound()`.

2. **SidebarControls** — `hasDeployed` derived from `userDeployed > 0` (tracked via `roundData` and `roundDeployed` events). Added to `canDeploy` as `!hasDeployed`. Button text changes to "✓ Deployed" when locked.

3. **MobileControls** — Same `hasDeployed` / `canDeploy` logic. Tracks `userDeployed` state via `roundData` (initial load) and `roundDeployed` (live SSE updates, matched against connected `userAddress` prop). Reset to 0 on `roundSettled`.

**Lifecycle:** User connects → loads round → backend returns `userDeployedFormatted` → if non-zero, grid and buttons are locked. User deploys → `userDeployed` event fires → grid locks immediately (optimistic). New round starts → `resetForNewRound()` clears `hasDeployedThisRound`, controls reset `userDeployed` to 0 on `roundSettled`.

### AutoMiner Integration

The AutoMiner contract uses a single payable `setConfig(strategyId, numRounds, numBlocks)` to deposit BNB and configure in one transaction, and `stop()` to deactivate and refund remaining BNB.

**Frontend constants in `lib/contracts.ts`:**
- `MIN_DEPLOY_PER_BLOCK = 0.00001` — minimum BNB per block
- `EXECUTOR_FEE_BPS = 50` — 0.5% executor fee deducted from deposits

**Fee-adjusted validation:** Frontend mirrors contract formula to validate per-block amount:
```typescript
const effectiveAmountPerBlock = (deposit × 10000) / (numBlocks × numRounds × (10000 + EXECUTOR_FEE_BPS))
```

**UI States:**
1. **Manual mode** — Normal block selection and deploy flow
2. **Auto Configure** — Input BNB deposit, strategy (All/Random), blocks (if random), rounds. Shows calculated per-block and per-round amounts.
3. **Auto Active** — When `autoMinerState.active === true`. Hides Manual tab, shows status: balance (refundable), strategy, rounds executed/total, per block. Stop button triggers refund.

**Real-time updates via `useSSE()`:**
- SidebarControls/MobileControls use `subscribeUser()` for `autoMineExecuted`, `configDeactivated`, `stopped` events
- On any event, re-fetches `GET /api/automine/:address` to update display
- On `configDeactivated`, switches back to manual mode

**Grid highlighting for AutoMiner:**
- MiningGrid uses `subscribeUser('autoMineExecuted')` to add deployed blocks to `userDeployedBlocks` Set
- Also handles AutoMiner in global `deployed` SSE (via `subscribeGlobal`): when `isAutoMine === true` and user matches, fetches `/api/user/:address/history?type=deploy&roundId=X&limit=1`, decodes `blockMask`, and updates `userDeployedBlocks`
- This dual approach handles the race condition where user SSE may not be connected for the first round

**Grid lock in AutoMiner mode:**
- When `autoMode.enabled === true`, all grid cell clicks are disabled
- Prevents users from manually selecting/deselecting blocks while AutoMiner is active

**Window events:**
| Event | Dispatched By | Consumed By |
|-------|--------------|-------------|
| `autoMinerActivated` | page.tsx (setConfig success) | SidebarControls, MobileControls |
| `autoMinerStopped` | page.tsx (stop success) | SidebarControls, MobileControls |

### `lib/api.ts` Helpers

- **`apiFetch<T>(path)`** — Typed GET request to backend. Base URL from `NEXT_PUBLIC_API_URL` env var (default `http://localhost:3001`).

### Centralized SSE Architecture (`lib/SSEContext.tsx`)

The app uses a centralized SSE provider to maintain exactly **2 connections** per browser session (1 global + 1 user) instead of per-component connections that caused connection stacking and 429 rate limit errors.

**Provider setup in `lib/providers.tsx`:**
```tsx
function SSEWrapper({ children }: { children: React.ReactNode }) {
  const { address } = useAccount()
  return <SSEProvider userAddress={address}>{children}</SSEProvider>
}
```

**Usage in components:**
```tsx
import { useSSE } from '@/lib/SSEContext'

const { subscribeGlobal, subscribeUser } = useSSE()

// Subscribe to global events (round lifecycle)
useEffect(() => {
  const unsub = subscribeGlobal('deployed', (data) => { ... })
  return () => unsub()
}, [subscribeGlobal])

// Subscribe to user-specific events (claims, autominer)
useEffect(() => {
  const unsub = subscribeUser('claimedBNB', (data) => { ... })
  return () => unsub()
}, [subscribeUser])
```

**Connection lifecycle:**
- **Global connection** (`/api/events/rounds`) — Opens on app mount, never closes. Listens for: `gameStarted`, `deployed`, `roundSettled`
- **User connection** (`/api/user/{address}/events`) — Opens when wallet connects, closes on disconnect. Listens for: `autoMineExecuted`, `configDeactivated`, `stopped`, `claimedBNB`, `claimedBEAN`, `checkpointed`

**Components using `useSSE()`:**
| Component | Global Events | User Events |
|-----------|---------------|-------------|
| MiningGrid | `deployed`, `roundSettled`, `gameStarted` | `autoMineExecuted` |
| SidebarControls | — | `autoMineExecuted`, `configDeactivated`, `stopped` |
| MobileControls | — | `autoMineExecuted`, `configDeactivated`, `stopped` |
| ClaimRewards | — | `claimedBNB`, `claimedBEAN` |

### Global Page (`/global`)

The `/global` page displays protocol-wide statistics and historical data. Components render after client mount to prevent Next.js SSR hydration mismatches.

**Components:**
| Component | Data Source | Status |
|-----------|-------------|--------|
| **GlobalStats** | `GET /api/stats`, `GET /api/treasury/stats` | ✅ Connected |
| **MiningTable** | `GET /api/rounds` | ✅ Connected |
| **RevenueTable** | `GET /api/treasury/buybacks` | ✅ Connected |
| **LeaderboardTable** | `GET /api/leaderboard/miners`, `GET /api/leaderboard/earners` | ✅ Connected (Stakers tab pending) |

**Hydration Pattern:** Components using dynamic data (API fetches or `Math.random()`) must return `null` until after mount to prevent SSR/client mismatch:

```typescript
const [mounted, setMounted] = useState(false)

useEffect(() => {
    setMounted(true)
}, [])

// Early return before mount
if (!mounted) {
    return null
}
```

**MiningTable Data Flow:**
1. Fetches `GET /api/rounds?page=1&limit=12&settled=true` on mount
2. For "Beanpot" tab, adds `&beanpot=true` to filter rounds where `motherlodeAmount > 0`
3. Transforms API response using `formatWei()` for amounts and `getRelativeTime()` for timestamps
4. Server-side pagination via `page` query param

**MiningTable Column Mapping:**
| Column | API Field | Transform |
|--------|-----------|-----------|
| Round | `roundId` | `#${roundId.toLocaleString()}` |
| Block | `winningBlock` | `#${winningBlock}` |
| BEAN Winner | `beanWinner`, `isSplit` | "Split" badge if `isSplit`, else truncated address |
| Winners | `winnerCount` | Direct display |
| Deployed | `totalDeployed` | `parseFloat(wei) / 1e18` |
| Vaulted | `vaultedAmount` | `parseFloat(wei) / 1e18` |
| Winnings | `totalWinnings` | `parseFloat(wei) / 1e18` |
| Beanpot | `motherlodeAmount` | Format if > 0, else dash |
| Time | `settledAt` or `endTime` | Relative time string |

**RevenueTable Data Flow:**
1. Fetches `GET /api/treasury/buybacks?page=1&limit=12` on mount
2. Transforms API response using pre-formatted strings from backend
3. Server-side pagination via `page` query param

**RevenueTable Column Mapping:**
| Column | API Field | Transform |
|--------|-----------|-----------|
| Time | `timestamp` | `getRelativeTime()` → relative time string |
| Spent | `bnbSpentFormatted` | `parseFloat()` → BNB amount |
| Burned | `beanBurnedFormatted` | `parseFloat()` → BEAN amount |
| Yield Generated | `beanToStakersFormatted` | `parseFloat()` → BEAN amount |

**LeaderboardTable Data Flow:**
1. Fetches both endpoints in parallel on mount:
   - `GET /api/leaderboard/miners?period=all&limit=12` for Miners tab
   - `GET /api/leaderboard/earners?limit=12` for Unrefined tab
2. Transforms API responses to `LeaderboardEntry` format with rank, truncated address, and value
3. Stakers tab shows "Coming soon" empty state (no staking contract yet)

**LeaderboardTable Column Mapping:**
| Tab | API Endpoint | Value Field | Icon |
|-----|--------------|-------------|------|
| Miners | `/api/leaderboard/miners` | `totalDeployedFormatted` | BNB |
| Stakers | N/A (coming soon) | - | BEAN |
| Unrefined | `/api/leaderboard/earners` | `unclaimedFormatted` | BEAN |

**GlobalStats Data Flow:**
1. Fetches both endpoints in parallel on mount:
   - `GET /api/stats` for circulating supply (`totalSupplyFormatted`)
   - `GET /api/treasury/stats` for burned and protocol revenue
2. Max Supply is hardcoded (3,000,000 BEAN contract constant)

**GlobalStats Column Mapping:**
| Stat | Source | Field |
|------|--------|-------|
| Max Supply | Hardcoded | `3,000,000` |
| Circulating Supply | `/api/stats` | `totalSupplyFormatted` |
| Burned | `/api/treasury/stats` | `totalBurnedFormatted` |
| Protocol Revenue | `/api/treasury/stats` | `totalVaultedFormatted` |

---

## Backend API Reference

Backend located at `../Backend` (Express.js + MongoDB + ethers.js). Runs on **port 3001**.

### Global Stats

#### `GET /api/stats`
Global protocol statistics.
```json
{
  "totalSupply": "string",
  "totalSupplyFormatted": "string",
  "totalMinted": "string",
  "totalMintedFormatted": "string",
  "motherlodePool": "string",
  "motherlodePoolFormatted": "string",
  "prices": { "bean": { "usd": "string" }, "bnb": { "usd": "string" } },
  "fetchedAt": "ISO date"
}
```

#### `GET /api/price`
BEAN token price from DexScreener.
```json
{
  "priceUsd": "string",
  "priceNative": "string",
  "volume24h": "string",
  "liquidity": "string",
  "priceChange24h": "string",
  "fdv": "string",
  "fetchedAt": "ISO date"
}
```

#### `GET /api/treasury/stats`
Treasury and buyback stats.
```json
{
  "vaultedBNB": "string",
  "vaultedBNBFormatted": "string",
  "totalBurned": "string",
  "totalBurnedFormatted": "string",
  "totalToStakers": "string",
  "totalToStakersFormatted": "string",
  "totalBuybacks": "string",
  "totalBuybacksFormatted": "string",
  "lastRefresh": "ISO date"
}
```

#### `GET /api/treasury/buybacks?page=1&limit=12`
Paginated list of buyback transactions. **Connected by RevenueTable.tsx**.
```json
{
  "buybacks": [
    {
      "bnbSpent": "string",
      "bnbSpentFormatted": "string",
      "beanReceived": "string",
      "beanReceivedFormatted": "string",
      "beanBurned": "string",
      "beanBurnedFormatted": "string",
      "beanToStakers": "string",
      "beanToStakersFormatted": "string",
      "txHash": "string",
      "blockNumber": 0,
      "timestamp": "ISO date"
    }
  ],
  "pagination": { "page": 1, "limit": 12, "total": 50, "pages": 5 }
}
```

### Round Data

#### `GET /api/round/current?user=0x...`
Current active round. Optional `user` query param adds user-specific deployment data.
```json
{
  "roundId": "string",
  "startTime": "number (unix)",
  "endTime": "number (unix)",
  "totalDeployed": "string",
  "totalDeployedFormatted": "string",
  "motherlodePool": "string",
  "motherlodePoolFormatted": "string",
  "settled": false,
  "blocks": [
    { "id": 0, "deployed": "string", "deployedFormatted": "string", "minerCount": 0 }
  ],
  "userDeployed": "string",
  "userDeployedFormatted": "string"
}
```

#### `GET /api/round/:id`
Historical round by ID. Returns full round document including settlement data (`winningBlock`, `topMiner`, `topMinerReward`, `motherlodeAmount`, `isSplit`, `topMinerSeed`, `winnersDeployed`).

#### `GET /api/round/:id/miners`
Computed winning miners for a settled round. Calculates BNB rewards (proportional), BEAN rewards (split: proportional, non-split: weighted random replay using `topMinerSeed`), and motherlode bonus. Requires deployments stored with `blockNumber` + `logIndex` for correct ordering. **Connected by MinersPanel.tsx**.
```json
{
  "roundId": 0,
  "winningBlock": 0,
  "miners": [
    {
      "address": "string",
      "bnbReward": "string", "bnbRewardFormatted": "string",
      "beanReward": "string", "beanRewardFormatted": "string",
      "deployed": "string", "deployedFormatted": "string"
    }
  ]
}
```

#### `GET /api/rounds?page=1&limit=20&settled=true&beanpot=true`
Paginated list of rounds. Query params:
- `page` — Page number (1-indexed)
- `limit` — Results per page
- `settled=true` — Only return settled rounds
- `beanpot=true` — Only return rounds where motherlode was won (`motherlodeAmount > 0`)

**Connected by MiningTable.tsx** for the Mining leaderboard on `/global` page.

```json
{
  "rounds": [
    {
      "roundId": 123,
      "winningBlock": 14,
      "beanWinner": "0x1234...5678",
      "isSplit": false,
      "winnerCount": 5,
      "totalDeployed": "1000000000000000000",
      "vaultedAmount": "100000000000000000",
      "totalWinnings": "890000000000000000",
      "motherlodeAmount": "0",
      "settledAt": "2026-02-04T10:33:28.000Z",
      "endTime": "2026-02-04T10:33:22.000Z"
    }
  ],
  "pagination": { "page": 1, "limit": 20, "total": 100, "pages": 5 }
}
```

### User Data

**Rate limit:** 5 req/min/IP on all user endpoints.

#### `GET /api/user/:address`
User balances and game stats.
```json
{
  "address": "string",
  "balances": {
    "bean": "string", "beanFormatted": "string",
    "bnb": "string", "bnbFormatted": "string"
  },
  "stats": {
    "roundsPlayed": 0,
    "wins": 0,
    "totalDeployed": "string"
  }
}
```

#### `GET /api/user/:address/rewards`
Pending claimable rewards. Calls `GridMining.getTotalPendingRewards(address)` which returns `(pendingBNB, pendingUnrefinedBEAN, pendingRefinedBEAN, uncheckpointedRound)`. Backend computes fee (10% of unrefined only) and net.
```json
{
  "pendingBNB": "string",
  "pendingBNBFormatted": "string",
  "pendingBEAN": {
    "unrefined": "string", "unrefinedFormatted": "string",
    "refined": "string", "refinedFormatted": "string",
    "gross": "string", "grossFormatted": "string",
    "fee": "string", "feeFormatted": "string",
    "net": "string", "netFormatted": "string"
  },
  "uncheckpointedRound": "string"
}
```

#### `GET /api/user/:address/history?page=1&limit=20&type=deploy|claim|all`
User deployment and claim history.
```json
{
  "history": [
    { "...document fields", "historyType": "deploy | claim" }
  ],
  "pagination": { "page": 1, "limit": 20, "total": 50, "pages": 3 }
}
```

### Leaderboards

#### `GET /api/leaderboard/miners?period=24h|7d|30d|all&limit=20`
Top miners by total BNB deployed. **Connected by LeaderboardTable.tsx** (Miners tab).
```json
{
  "period": "all",
  "deployers": [
    {
      "address": "0x...",
      "totalDeployed": "5000000000000000000",
      "totalDeployedFormatted": "5.0",
      "roundsPlayed": 42
    }
  ]
}
```

#### `GET /api/leaderboard/earners?limit=20`
Top users by unclaimed BEAN (unrefined). **Connected by LeaderboardTable.tsx** (Unrefined tab).
```json
{
  "earners": [
    {
      "address": "0x...",
      "unclaimed": "500000000000000000",
      "unclaimedFormatted": "0.5"
    }
  ],
  "pagination": { "page": 1, "limit": 20, "total": 150, "pages": 8 }
}
```

### AutoMiner

#### `GET /api/automine/:address`
User's AutoMiner configuration and state. Rate limited (5/min). **Connected by SidebarControls.tsx and MobileControls.tsx**.
```json
{
  "config": {
    "strategyId": 0,
    "numBlocks": 0,
    "numRounds": 0,
    "roundsExecuted": 0,
    "amountPerBlockFormatted": "string",
    "depositAmountFormatted": "string",
    "active": true
  },
  "costPerRoundFormatted": "string",
  "roundsRemaining": 0,
  "totalRefundableFormatted": "string"
}
```

### Server-Sent Events (SSE)

#### `GET /api/events/rounds`
Global real-time event stream. Events:
- `gameStarted` — new round began (`{ roundId, startTime, endTime, motherlodePool, motherlodePoolFormatted }`)
- `deployed` — a user deployed BNB to blocks (`{ roundId, user, totalAmount, isAutoMine, totalDeployed, totalDeployedFormatted, userDeployed, userDeployedFormatted, blocks[] }`) — note: `userDeployed*` fields are for the deploying user, not the receiving client
- `roundSettled` — round completed with winner (`{ roundId, winningBlock, topMiner, totalWinnings, topMinerReward, motherlodeAmount, isSplit }`)
- `heartbeat` — keep-alive every 30s

#### `GET /api/user/:address/events`
User-specific event stream. **Connected by ClaimRewards.tsx, SidebarControls.tsx, MobileControls.tsx, and MiningGrid.tsx**.
- `claimedBNB` — user claimed BNB rewards (`{ amount, txHash, timestamp }`)
- `claimedBEAN` — user claimed BEAN rewards (`{ gross, fee, net, txHash, timestamp }`)
- `checkpointed` — reward checkpoint processed
- `autoMineExecuted` — AutoMiner deployed on user's behalf (`{ roundId, blocks[], totalDeployed, fee, roundsExecuted }`)
- `configDeactivated` — AutoMiner completed all rounds (`{ roundsCompleted }`)
- `stopped` — AutoMiner manually stopped (`{ refundAmount, roundsCompleted }`)
- `heartbeat` — keep-alive every 30s

### Health Check

#### `GET /health`
Returns service status for MongoDB, blockchain, and cache subsystems.

### Rate Limits

| Scope | Limit |
|-------|-------|
| Default (`/api/*`) | 60 req/min/IP |
| Strict (user, rewards, automine) | 5 req/min/IP |
| SSE connections | 10 per IP, 1000 total |

=== ./app/about/page.tsx ===
'use client'

import Header from '@/components/Header'
import AboutPage from '@/components/AboutPage'
import BottomNav from '@/components/BottomNav'
import { useState, useEffect } from 'react'

export default function About() {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  return (
    <div style={{ minHeight: '100vh', background: '#0a0a0a', paddingBottom: isMobile ? '80px' : '0' }}>
      <Header currentPage="about" isMobile={isMobile} />
      <AboutPage isMobile={isMobile} />
      {isMobile && <BottomNav currentPage="about" />}
    </div>
  )
}

=== ./app/global/page.tsx ===
'use client'

import Header from '@/components/Header'
import GlobalStats from '@/components/GlobalStats'
import MiningTable from '@/components/MiningTable'
import RevenueTable from '@/components/RevenueTable'
import LeaderboardTable from '@/components/LeaderboardTable'
import BottomNav from '@/components/BottomNav'
import { useState, useEffect } from 'react'

export default function Global() {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  return (
    <div style={{ minHeight: '100vh', background: '#0a0a0a', paddingBottom: isMobile ? '80px' : '0' }}>
      <Header currentPage="global" isMobile={isMobile} />
      
      <div style={isMobile ? styles.mobileContainer : styles.container}>
        <GlobalStats isMobile={isMobile} />
        <MiningTable />
        <RevenueTable />
        <LeaderboardTable />
      </div>
      
      {isMobile && <BottomNav currentPage="global" />}
    </div>
  )
}

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    maxWidth: '1200px',
    margin: '0 auto',
    padding: '0 40px 60px',
  },
  mobileContainer: {
    padding: '16px',
    overflowX: 'hidden',
  },
}

=== ./app/globals.css ===
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  background: #0a0a0a;
  color: #fff;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #111;
}

::-webkit-scrollbar-thumb {
  background: #333;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #444;
}

/* Selection styling */
::selection {
  background: rgba(240, 185, 11, 0.3);
  color: #fff;
}

/* Button reset */
button {
  font-family: inherit;
}

/* Input reset */
input {
  font-family: inherit;
}

/* Remove number input spinners */
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type="number"] {
  -moz-appearance: textfield;
}

/* Mobile Responsive Styles */
@media (max-width: 768px) {
  /* Header */
  .mobile-header {
    flex-direction: column;
    padding: 12px 16px !important;
    gap: 12px;
  }

  /* Hide on mobile */
  .hide-mobile {
    display: none !important;
  }

  /* Show on mobile */
  .show-mobile {
    display: flex !important;
  }

  /* Main container */
  .main-container {
    flex-direction: column !important;
    padding: 16px !important;
    gap: 16px !important;
  }

  /* Controls section */
  .controls-section {
    width: 100% !important;
    order: -1;
  }

  /* Grid section */
  .grid-section {
    width: 100% !important;
  }

  /* Mining grid */
  .mining-grid {
    grid-template-columns: repeat(5, 1fr) !important;
    gap: 4px !important;
  }

  .mining-cell {
    min-height: 60px !important;
    padding: 8px !important;
  }

  .cell-amount {
    font-size: 11px !important;
  }

  .cell-id {
    font-size: 10px !important;
  }
}

/* Custom Connect Wallet button styling */
[data-rk] button[data-testid="rk-connect-button"] {
  background: transparent !important;
  border: 1px solid #333 !important;
  color: #fff !important;
  font-weight: 500 !important;
  padding: 10px 20px !important;
  border-radius: 50px !important;
  transition: all 0.2s ease !important;
}

[data-rk] button[data-testid="rk-connect-button"]:hover {
  border-color: #F0B90B !important;
  background: rgba(240, 185, 11, 0.1) !important;
}

/* Connected wallet button styling */
[data-rk] button[data-testid="rk-account-button"] {
  background: #1a1a1a !important;
  border: 1px solid #333 !important;
  border-radius: 50px !important;
  padding: 4px 12px !important;
  transition: all 0.2s ease !important;
}

[data-rk] button[data-testid="rk-account-button"]:hover {
  border-color: #444 !important;
  background: #222 !important;
}


/* Hide the chain button (BNB dropdown) */
[data-rk] button[data-testid="rk-chain-button"] {
  display: none !important;
}

/* Hide only the avatar image */
[data-rk] button[data-testid="rk-account-button"] img {
  display: none !important;
}

/* Hide avatar container */
[data-rk] button[data-testid="rk-account-button"] > div > div:has(img) {
  display: none !important;
}

/* Alternative: hide by size */
[data-rk] button[data-testid="rk-account-button"] [style*="width: 24px"] {
  display: none !important;
}

/* Force smaller button size */
[data-rk] button[data-testid="rk-account-button"] {
  height: 36px !important;
  min-height: unset !important;
}

[data-rk] button[data-testid="rk-account-button"] > div {
  height: 100% !important;
  padding: 0 !important;
}

/* Smaller text in wallet button */
[data-rk] button[data-testid="rk-account-button"] {
  font-size: 13px !important;
}

/* Taller navbar */
header {
  padding-top: 24px !important;
  padding-bottom: 24px !important;
}

=== ./app/layout.tsx ===
import type { Metadata } from 'next'
import { Web3Provider } from '@/lib/providers'
import './globals.css'

export const metadata: Metadata = {
  title: 'MineBean',
  description: 'Decentralized mining protocol on BSC',
  icons: {
    icon: '/favicon.svg',
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <link
          href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
          rel="stylesheet"
        />
      </head>
      <body>
        <Web3Provider>
          {children}
        </Web3Provider>
      </body>
    </html>
  )
}

=== ./app/page.tsx ===
'use client'

import Header from '@/components/Header'
import MinersPanel from '@/components/MinersPanel'
import MiningGrid from '@/components/MiningGrid'
import SidebarControls from '@/components/SidebarControls'
import MobileStatsBar from '@/components/MobileStatsBar'
import MobileControls from '@/components/MobileControls'
import BottomNav from '@/components/BottomNav'
import LandingPage from '@/components/LandingPage'
import ClaimRewards from '@/components/ClaimRewards'
import { useAccount, useBalance, useWriteContract } from 'wagmi'
import { parseEther } from 'viem'
import { useState, useEffect, useCallback } from 'react'
import { CONTRACTS } from '@/lib/contracts'

export default function Home() {
  const { address, isConnected } = useAccount()
  const { data: balance } = useBalance({ address })
  const [isMobile, setIsMobile] = useState(false)
  const [showMining, setShowMining] = useState(false)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  const { writeContract } = useWriteContract()
  const userBalance = balance ? parseFloat(balance.formatted) : 0

  const handleDeploy = useCallback((amount: number, blockIds: number[]) => {
    if (!isConnected || blockIds.length === 0 || amount <= 0) return
    writeContract({
      address: CONTRACTS.GridMining.address,
      abi: CONTRACTS.GridMining.abi,
      functionName: 'deploy',
      args: [blockIds],
      value: parseEther(amount.toString()),
    }, {
      onSuccess: () => {
        window.dispatchEvent(new CustomEvent("userDeployed", {
          detail: { blockIds }
        }))
      }
    })
  }, [isConnected, writeContract])

  const handleClaimBNB = useCallback(() => {
    if (!isConnected) return
    writeContract({
      address: CONTRACTS.GridMining.address,
      abi: CONTRACTS.GridMining.abi,
      functionName: 'claimBNB',
      args: [],
    })
  }, [isConnected, writeContract])

  const handleClaimBEAN = useCallback(() => {
    if (!isConnected) return
    writeContract({
      address: CONTRACTS.GridMining.address,
      abi: CONTRACTS.GridMining.abi,
      functionName: 'claimBEAN',
      args: [],
    })
  }, [isConnected, writeContract])

  const handleAutoActivate = useCallback((strategyId: number, numRounds: number, numBlocks: number, depositAmount: bigint) => {
    if (!isConnected) return
    writeContract({
      address: CONTRACTS.AutoMiner.address,
      abi: CONTRACTS.AutoMiner.abi,
      functionName: 'setConfig',
      args: [strategyId, numRounds, numBlocks],
      value: depositAmount,
    }, {
      onSuccess: () => {
        window.dispatchEvent(new CustomEvent("autoMinerActivated"))
      }
    })
  }, [isConnected, writeContract])

  const handleAutoStop = useCallback(() => {
    if (!isConnected) return
    writeContract({
      address: CONTRACTS.AutoMiner.address,
      abi: CONTRACTS.AutoMiner.abi,
      functionName: 'stop',
      args: [],
    }, {
      onSuccess: () => {
        window.dispatchEvent(new CustomEvent("autoMinerStopped"))
      }
    })
  }, [isConnected, writeContract])

  if (!showMining) {
    return <LandingPage onStartMining={() => setShowMining(true)} />
  }

  if (isMobile) {
    return (
      <div style={{ minHeight: '100vh', background: '#0a0a0a', paddingBottom: '80px' }}>
        <Header currentPage="home" isMobile={true} />
        <div style={styles.mobileContainer}>
          <MobileStatsBar userAddress={address} />
          <MiningGrid userAddress={address} />
          <MobileControls isConnected={isConnected} userBalance={userBalance} userAddress={address} onDeploy={handleDeploy} onAutoActivate={handleAutoActivate} onAutoStop={handleAutoStop} />
          <ClaimRewards userAddress={address} onClaimBNB={handleClaimBNB} onClaimBEAN={handleClaimBEAN} />
        </div>
        <BottomNav currentPage="mine" />
      </div>
    )
  }

  return (
    <div style={{ minHeight: '100vh', background: '#0a0a0a' }}>
      <Header currentPage="home" />
      <div style={styles.container}>
        <MinersPanel />
        <div style={styles.gridSection}>
          <MiningGrid userAddress={address} />
        </div>
        <div style={styles.controlsSection}>
          <SidebarControls isConnected={isConnected} userBalance={userBalance} userAddress={address} onDeploy={handleDeploy} onAutoActivate={handleAutoActivate} onAutoStop={handleAutoStop} />
          <ClaimRewards userAddress={address} onClaimBNB={handleClaimBNB} onClaimBEAN={handleClaimBEAN} />
        </div>
      </div>
    </div>
  )
}

const styles: { [key: string]: React.CSSProperties } = {
  container: {
    display: 'flex',
    gap: '24px',
    padding: '24px 40px',
    paddingRight: '120px',
    maxWidth: '1400px',
    margin: '0 auto',
  },
  mobileContainer: {
    display: 'flex',
    flexDirection: 'column',
    gap: '12px',
    padding: '12px',
  },
  gridSection: {
    flex: 1,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'flex-start',
  },
  controlsSection: {
    width: '340px',
    flexShrink: 0,
  },
}

=== ./app/stake/page.tsx ===
'use client'

import Header from '@/components/Header'
import BottomNav from '@/components/BottomNav'
import StakePage from '@/components/StakePage'
import { useAccount, useBalance } from 'wagmi'
import { useState, useEffect } from 'react'

export default function Stake() {
  const { address, isConnected } = useAccount()
  const { data: balance } = useBalance({ address })
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  const userBalance = balance ? parseFloat(balance.formatted) : 0

  return (
    <div style={{ minHeight: '100vh', background: '#0a0a0a', paddingBottom: isMobile ? '80px' : '0' }}>
      <Header currentPage="stake" isMobile={isMobile} />
      <StakePage
        isConnected={isConnected}
        userBalance={userBalance}
        isMobile={isMobile}
      />
      {isMobile && <BottomNav currentPage="stake" />}
    </div>
  )
}

=== ./components/AboutPage.tsx ===
'use client'

import React, { useState } from "react"

interface AboutPageProps {
    initialSection?: string
    isMobile?: boolean
}

export default function AboutPage({
    initialSection = "overview",
    isMobile = false,
}: AboutPageProps) {
    const [activeSection, setActiveSection] = useState(initialSection)
    const [expandedItems, setExpandedItems] = useState<string[]>(["how-it-works", "tokenomics"])

    const toggleExpanded = (id: string) => {
        setExpandedItems((prev) => prev.includes(id) ? prev.filter((i) => i !== id) : [...prev, id])
    }

    const navigation = [
        { id: "overview", label: "Overview" },
        { id: "how-it-works", label: "How It Works", children: [
            { id: "mining", label: "Mining" },
            { id: "beanpot", label: "The Beanpot" },
            { id: "golden-bean", label: "Golden Bean" },
            { id: "refining", label: "Refining" },
        ]},
        { id: "tokenomics", label: "Tokenomics", children: [
            { id: "supply", label: "Supply" },
            { id: "protocol-revenue", label: "Protocol Revenue" },
            { id: "burn", label: "Burn Mechanism" },
        ]},
        { id: "staking", label: "Staking" },
        { id: "faq", label: "FAQ" },
    ]

    const sectionGap = isMobile ? "28px" : "40px"
    const paragraphGap = isMobile ? "16px" : "20px"
    const listGap = isMobile ? "12px" : "16px"

    const content: Record<string, { title: string; content: React.ReactNode }> = {
        overview: {
            title: "Overview",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: paragraphGap }}>
                    <p style={{ margin: 0 }}><strong>BEANS</strong> is a gamified mining protocol on BNB Chain where players compete in 60-second rounds to earn rewards.</p>
                    <p style={{ margin: 0 }}>Deploy BNB on a 5×5 grid of 25 blocks. At the end of each round, one winning block is randomly selected. Players on the winning block share the BNB from all losing blocks, proportional to their deployment.</p>
                    <p style={{ margin: 0 }}>Each round also emits BEANS tokens to winners, with bonus jackpots and rewards for patient miners who delay claiming.</p>
                    <div style={isMobile ? styles.infoBoxMobile : styles.infoBox}>
                        <strong>Why BEANS?</strong>
                        <p style={{ margin: "12px 0 0 0" }}>Just like coffee beans need to be refined and roasted to reach their full potential, BEANS tokens reward patience. The longer you let your mined BEANS roast (remain unclaimed), the more you earn from the refining mechanism.</p>
                    </div>
                </div>
            ),
        },
        mining: {
            title: "Mining",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}>Mining is the core mechanic of BEANS. Each round lasts 60 seconds and takes place on a 5×5 grid of 25 blocks.</p>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>How It Works</h3>
                        <ol style={{ ...styles.list, gap: listGap }}>
                            <li><strong>Deploy BNB</strong> – Choose which block(s) to deploy your BNB on.</li>
                            <li><strong>Wait for the round to end</strong> – Each round lasts 60 seconds.</li>
                            <li><strong>Winning block selected</strong> – A secure random number generator selects one winning block.</li>
                            <li><strong>Rewards distributed</strong> – BNB from losing blocks goes to winners proportionally.</li>
                        </ol>
                    </div>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>Strategy</h3>
                        <ul style={{ ...styles.list, gap: listGap }}>
                            <li><strong>Spread your BNB</strong> across multiple blocks for higher win chance but smaller payouts</li>
                            <li><strong>Concentrate on fewer blocks</strong> for lower chance but larger payouts</li>
                            <li><strong>Cover all 25 blocks</strong> to guarantee winning (minus protocol fees)</li>
                        </ul>
                    </div>
                </div>
            ),
        },
        beanpot: {
            title: "The Beanpot",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}>The <strong>Beanpot</strong> is a growing jackpot pool that adds excitement to every round.</p>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>How It Works</h3>
                        <ol style={{ ...styles.list, gap: listGap }}>
                            <li>Each round, <strong>0.2 BEANS</strong> is added to the Beanpot.</li>
                            <li>There is a <strong>1-in-625 chance</strong> the Beanpot is hit each round.</li>
                            <li>If hit, the pool is split among winners proportionally.</li>
                            <li>If not hit, it keeps growing.</li>
                        </ol>
                    </div>
                </div>
            ),
        },
        "golden-bean": {
            title: "Golden Bean",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}>The <strong>Golden Bean</strong> is a +1 BEANS bonus awarded to one miner on the winning block each round.</p>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>How It Works</h3>
                        <ol style={{ ...styles.list, gap: listGap }}>
                            <li>Each round, one miner receives <strong>+1 BEANS</strong> bonus.</li>
                            <li>Winner selected randomly, weighted by deployment amount.</li>
                            <li>Sometimes split among all winners instead.</li>
                        </ol>
                    </div>
                </div>
            ),
        },
        refining: {
            title: "Refining",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}><strong>Refining</strong> rewards patient miners who delay claiming.</p>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>How It Works</h3>
                        <ol style={{ ...styles.list, gap: listGap }}>
                            <li>Won BEANS are <strong>unrefined</strong> until claimed.</li>
                            <li>Claiming applies a <strong>10% refining fee</strong>.</li>
                            <li>This fee redistributes to miners with unclaimed BEANS.</li>
                            <li>Longer holds = more bonus BEANS.</li>
                        </ol>
                    </div>
                </div>
            ),
        },
        supply: {
            title: "Supply",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>Token Details</h3>
                        <table style={styles.table}>
                            <tbody>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Token Name</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>BEANS</td></tr>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Network</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>BNB Chain (BSC)</td></tr>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Max Supply</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>3,000,000 BEANS</td></tr>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Initial Supply</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>0</td></tr>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Emission Rate</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>~1 BEANS per round</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            ),
        },
        "protocol-revenue": {
            title: "Protocol Revenue",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}>BEANS generates protocol revenue from mining activity.</p>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>Revenue Usage</h3>
                        <table style={styles.table}>
                            <tbody>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Buyback & Burn</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>90% of revenue</td></tr>
                                <tr><td style={isMobile ? styles.tableLabelMobile : styles.tableLabel}>Staker Rewards</td><td style={isMobile ? styles.tableValueMobile : styles.tableValue}>10% of revenue</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            ),
        },
        burn: {
            title: "Burn Mechanism",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}>BEANS is designed to be <strong>deflationary</strong>.</p>
                    <p style={{ margin: 0 }}>90% of all BEANS bought with protocol revenue are permanently burned.</p>
                </div>
            ),
        },
        staking: {
            title: "Staking",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <p style={{ margin: 0 }}>Stake your BEANS to earn a share of protocol revenue.</p>
                    <div>
                        <h3 style={isMobile ? styles.h3Mobile : styles.h3}>How Staking Works</h3>
                        <ol style={{ ...styles.list, gap: listGap }}>
                            <li><strong>Deposit BEANS</strong> into the staking contract</li>
                            <li><strong>Earn rewards</strong> from protocol revenue</li>
                            <li><strong>Withdraw anytime</strong> – no lock-up period</li>
                        </ol>
                    </div>
                </div>
            ),
        },
        faq: {
            title: "FAQ",
            content: (
                <div style={{ display: "flex", flexDirection: "column", gap: sectionGap }}>
                    <div style={styles.faqItem}>
                        <h4 style={isMobile ? styles.h4Mobile : styles.h4}>What is BEANS?</h4>
                        <p style={{ margin: "12px 0 0 0" }}>A gamified mining protocol on BNB Chain with 60-second rounds.</p>
                    </div>
                    <div style={styles.faqItem}>
                        <h4 style={isMobile ? styles.h4Mobile : styles.h4}>Can I lose my BNB?</h4>
                        <p style={{ margin: "12px 0 0 0" }}>Yes, if your block doesn't win. Cover all 25 blocks to guarantee wins.</p>
                    </div>
                    <div style={styles.faqItem}>
                        <h4 style={isMobile ? styles.h4Mobile : styles.h4}>What is refining?</h4>
                        <p style={{ margin: "12px 0 0 0" }}>A 10% fee on claims redistributed to patient miners.</p>
                    </div>
                </div>
            ),
        },
    }

    if (isMobile) {
        return (
            <div style={styles.mobileContainer}>
                <aside style={styles.mobileSidebar}>
                    <div style={styles.mobileSidebarHeader}>
                        <span style={styles.mobileSidebarTitle}>Docs</span>
                    </div>
                    <nav style={styles.mobileSidebarNav}>
                        {navigation.map((item) => (
                            <div key={item.id}>
                                {item.children ? (
                                    <>
                                        <button style={{ ...styles.mobileNavParent, ...(expandedItems.includes(item.id) ? styles.mobileNavParentExpanded : {}) }} onClick={() => toggleExpanded(item.id)}>
                                            <span>{item.label}</span>
                                            <span style={{ ...styles.chevron, transform: expandedItems.includes(item.id) ? "rotate(90deg)" : "rotate(0deg)" }}>›</span>
                                        </button>
                                        {expandedItems.includes(item.id) && (
                                            <div style={styles.mobileNavChildren}>
                                                {item.children.map((child) => (
                                                    <button key={child.id} style={{ ...styles.mobileNavChild, ...(activeSection === child.id ? styles.mobileNavChildActive : {}) }} onClick={() => setActiveSection(child.id)}>{child.label}</button>
                                                ))}
                                            </div>
                                        )}
                                    </>
                                ) : (
                                    <button style={{ ...styles.mobileNavItem, ...(activeSection === item.id ? styles.mobileNavItemActive : {}) }} onClick={() => setActiveSection(item.id)}>{item.label}</button>
                                )}
                            </div>
                        ))}
                    </nav>
                </aside>
                <main style={styles.mobileMain}>
                    <article style={styles.mobileArticle}>
                        <h1 style={styles.mobileTitle}>{content[activeSection]?.title || "Overview"}</h1>
                        <div style={styles.mobileContent}>{content[activeSection]?.content || content.overview.content}</div>
                    </article>
                </main>
            </div>
        )
    }

    return (
        <div style={styles.container}>
            <aside style={styles.sidebar}>
                <div style={styles.sidebarHeader}>
                    <span style={styles.sidebarTitle}>BEANS Docs</span>
                </div>
                <nav style={styles.sidebarNav}>
                    {navigation.map((item) => (
                        <div key={item.id}>
                            {item.children ? (
                                <>
                                    <button style={{ ...styles.navParent, ...(expandedItems.includes(item.id) ? styles.navParentExpanded : {}) }} onClick={() => toggleExpanded(item.id)}>
                                        <span>{item.label}</span>
                                        <span style={{ ...styles.chevron, transform: expandedItems.includes(item.id) ? "rotate(90deg)" : "rotate(0deg)" }}>›</span>
                                    </button>
                                    {expandedItems.includes(item.id) && (
                                        <div style={styles.navChildren}>
                                            {item.children.map((child) => (
                                                <button key={child.id} style={{ ...styles.navChild, ...(activeSection === child.id ? styles.navChildActive : {}) }} onClick={() => setActiveSection(child.id)}>{child.label}</button>
                                            ))}
                                        </div>
                                    )}
                                </>
                            ) : (
                                <button style={{ ...styles.navItem, ...(activeSection === item.id ? styles.navItemActive : {}) }} onClick={() => setActiveSection(item.id)}>{item.label}</button>
                            )}
                        </div>
                    ))}
                </nav>
            </aside>
            <main style={styles.main}>
                <article style={styles.article}>
                    <h1 style={styles.title}>{content[activeSection]?.title || "Overview"}</h1>
                    <div style={styles.content}>{content[activeSection]?.content || content.overview.content}</div>
                </article>
            </main>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: { display: "flex", minHeight: "100vh", background: "#0a0a0a", fontFamily: "'Inter', -apple-system, sans-serif" },
    sidebar: { width: "280px", borderRight: "1px solid #1a1a1a", padding: "24px 0", position: "sticky", top: 0, height: "100vh", overflowY: "auto" },
    sidebarHeader: { display: "flex", alignItems: "center", gap: "10px", padding: "0 24px 24px", borderBottom: "1px solid #1a1a1a", marginBottom: "16px" },
    sidebarTitle: { fontSize: "18px", fontWeight: 700, color: "#fff" },
    sidebarNav: { padding: "0 12px" },
    navItem: { display: "flex", alignItems: "center", gap: "8px", width: "100%", padding: "10px 12px", background: "transparent", border: "none", borderRadius: "6px", color: "#888", fontSize: "14px", fontWeight: 500, cursor: "pointer", textAlign: "left", fontFamily: "inherit" },
    navItemActive: { background: "#1a1a1a", color: "#fff" },
    navParent: { display: "flex", alignItems: "center", justifyContent: "space-between", width: "100%", padding: "10px 12px", background: "transparent", border: "none", borderRadius: "6px", color: "#888", fontSize: "14px", fontWeight: 500, cursor: "pointer", textAlign: "left", fontFamily: "inherit" },
    navParentExpanded: { color: "#fff" },
    chevron: { fontSize: "16px", transition: "transform 0.15s" },
    navChildren: { paddingLeft: "20px", marginTop: "4px" },
    navChild: { display: "block", width: "100%", padding: "8px 12px", background: "transparent", border: "none", borderLeft: "2px solid #333", color: "#666", fontSize: "13px", fontWeight: 500, cursor: "pointer", textAlign: "left", fontFamily: "inherit" },
    navChildActive: { borderLeftColor: "#F0B90B", color: "#fff", background: "#1a1a1a" },
    main: { flex: 1, padding: "48px 48px 80px", maxWidth: "800px" },
    article: { color: "#fff" },
    title: { fontSize: "36px", fontWeight: 700, marginBottom: "40px", color: "#fff" },
    content: { fontSize: "16px", lineHeight: 1.8, color: "#ccc" },
    h3: { fontSize: "20px", fontWeight: 600, color: "#fff", margin: "0 0 16px 0" },
    h4: { fontSize: "18px", fontWeight: 600, color: "#fff", margin: 0 },
    list: { margin: 0, paddingLeft: "24px", display: "flex", flexDirection: "column" },
    infoBox: { background: "#1a1a1a", border: "1px solid #333", borderRadius: "12px", padding: "20px", marginTop: "8px" },
    table: { width: "100%", borderCollapse: "collapse", marginTop: "8px" },
    tableLabel: { padding: "14px 16px", borderBottom: "1px solid #222", color: "#888", fontWeight: 500, fontSize: "15px" },
    tableValue: { padding: "14px 16px", borderBottom: "1px solid #222", color: "#fff", textAlign: "right", fontSize: "15px" },
    faqItem: { borderBottom: "1px solid #222", paddingBottom: "32px" },
    mobileContainer: { display: "flex", minHeight: "100vh", background: "#0a0a0a", fontFamily: "'Inter', -apple-system, sans-serif" },
    mobileSidebar: { width: "120px", borderRight: "1px solid #1a1a1a", padding: "12px 0", flexShrink: 0 },
    mobileSidebarHeader: { padding: "0 10px 10px", borderBottom: "1px solid #1a1a1a", marginBottom: "8px" },
    mobileSidebarTitle: { fontSize: "13px", fontWeight: 700, color: "#fff" },
    mobileSidebarNav: { padding: "0 4px" },
    mobileNavItem: { display: "flex", alignItems: "center", width: "100%", padding: "8px 6px", background: "transparent", border: "none", borderRadius: "4px", color: "#888", fontSize: "12px", fontWeight: 500, cursor: "pointer", textAlign: "left", fontFamily: "inherit" },
    mobileNavItemActive: { background: "#1a1a1a", color: "#fff" },
    mobileNavParent: { display: "flex", alignItems: "center", justifyContent: "space-between", width: "100%", padding: "8px 6px", background: "transparent", border: "none", borderRadius: "4px", color: "#888", fontSize: "12px", fontWeight: 500, cursor: "pointer", textAlign: "left", fontFamily: "inherit" },
    mobileNavParentExpanded: { color: "#fff" },
    mobileNavChildren: { paddingLeft: "6px", marginTop: "2px" },
    mobileNavChild: { display: "block", width: "100%", padding: "6px 6px", background: "transparent", border: "none", borderLeft: "2px solid #333", color: "#666", fontSize: "11px", fontWeight: 500, cursor: "pointer", textAlign: "left", fontFamily: "inherit" },
    mobileNavChildActive: { borderLeftColor: "#F0B90B", color: "#fff", background: "#1a1a1a" },
    mobileMain: { flex: 1, padding: "16px 16px 80px", overflowX: "hidden" },
    mobileArticle: { color: "#fff" },
    mobileTitle: { fontSize: "22px", fontWeight: 700, marginBottom: "24px", color: "#fff" },
    mobileContent: { fontSize: "14px", lineHeight: 1.7, color: "#ccc" },
    h3Mobile: { fontSize: "16px", fontWeight: 600, color: "#fff", margin: "0 0 12px 0" },
    h4Mobile: { fontSize: "15px", fontWeight: 600, color: "#fff", margin: 0 },
    infoBoxMobile: { background: "#1a1a1a", border: "1px solid #333", borderRadius: "10px", padding: "14px", marginTop: "8px", fontSize: "13px" },
    tableLabelMobile: { padding: "10px 10px", borderBottom: "1px solid #222", color: "#888", fontWeight: 500, fontSize: "13px" },
    tableValueMobile: { padding: "10px 10px", borderBottom: "1px solid #222", color: "#fff", textAlign: "right", fontSize: "13px" },
}
=== ./components/BeanLogo.tsx ===
'use client'

export default function BeanLogo({ size = 32 }: { size?: number }) {
  return (
    <svg width={size} height={size} viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
      <ellipse cx="50" cy="50" rx="38" ry="45" fill="url(#beanGradient)" />
      <path d="M50 20C45 35 45 65 50 80" stroke="#C4940A" strokeWidth="4" strokeLinecap="round" fill="none" opacity="0.6" />
      <ellipse cx="38" cy="35" rx="8" ry="6" fill="white" opacity="0.3" />
      <defs>
        <linearGradient id="beanGradient" x1="50" y1="5" x2="50" y2="95" gradientUnits="userSpaceOnUse">
          <stop offset="0%" stopColor="#FFD54F" />
          <stop offset="100%" stopColor="#F0B90B" />
        </linearGradient>
      </defs>
    </svg>
  )
}

export function BeansTextLogo({ height = 24 }: { height?: number }) {
  return (
    <span style={{ display: 'flex', alignItems: 'center', fontWeight: 800, fontSize: height, letterSpacing: '-0.02em', fontFamily: "'Inter', -apple-system, sans-serif" }}>
      <span style={{ color: '#fff' }}>BE</span>
      <span style={{ color: '#F0B90B' }}>ANS</span>
      <span style={{ color: '#fff', marginLeft: '2px' }}>.</span>
    </span>
  )
}

=== ./components/BottomNav.tsx ===
'use client'

import React from "react"
import Link from "next/link"

interface BottomNavProps {
    currentPage: string
}

export default function BottomNav({ currentPage }: BottomNavProps) {
    const navItems = [
        { 
            id: 'mine', 
            label: 'Mine', 
            href: '/',
            icon: (active: boolean) => (
                <svg width="22" height="22" viewBox="0 0 24 24" fill={active ? "#F0B90B" : "#666"}>
                    <path d="M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66l.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21z" />
                </svg>
            )
        },
        { 
            id: 'about', 
            label: 'About', 
            href: '/about',
            icon: (active: boolean) => (
                <svg width="22" height="22" viewBox="0 0 24 24" fill={active ? "#F0B90B" : "#666"}>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
                </svg>
            )
        },
        { 
            id: 'global', 
            label: 'Global', 
            href: '/global',
            icon: (active: boolean) => (
                <svg width="22" height="22" viewBox="0 0 24 24" fill={active ? "#F0B90B" : "#666"}>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" />
                </svg>
            )
        },
        { 
            id: 'stake', 
            label: 'Stake', 
            href: '/stake',
            icon: (active: boolean) => (
                <svg width="22" height="22" viewBox="0 0 24 24" fill={active ? "#F0B90B" : "#666"}>
                    <path d="M12 2L4 7v10l8 5 8-5V7l-8-5zm0 2.18l6 3.75v7.14l-6 3.75-6-3.75V7.93l6-3.75z" />
                    <path d="M12 6.5L8 9v6l4 2.5 4-2.5V9l-4-2.5z" />
                </svg>
            )
        },
    ]

    return (
        <nav style={styles.nav}>
            {navItems.map((item) => {
                const isActive = currentPage === item.id
                return (
                    <Link
                        key={item.id}
                        href={item.href}
                        style={{
                            ...styles.navItem,
                            ...(isActive ? styles.navItemActive : {}),
                        }}
                    >
                        {item.icon(isActive)}
                        <span style={styles.navLabel}>{item.label}</span>
                    </Link>
                )
            })}
        </nav>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    nav: {
        position: 'fixed',
        bottom: 0,
        left: 0,
        right: 0,
        display: 'flex',
        justifyContent: 'space-around',
        alignItems: 'center',
        background: '#0a0a0a',
        borderTop: '1px solid #222',
        padding: '10px 0 16px 0',
        fontFamily: "'Inter', -apple-system, sans-serif",
        zIndex: 1000,
    },
    navItem: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        gap: '4px',
        color: '#666',
        fontSize: '10px',
        fontWeight: 600,
        textDecoration: 'none',
        padding: '4px 8px',
    },
    navItemActive: {
        color: '#F0B90B',
    },
    navLabel: {
        fontSize: '10px',
    },
}

=== ./components/ClaimRewards.tsx ===
'use client'

import React, { useState, useEffect, useCallback } from "react"
import { apiFetch } from '@/lib/api'
import { useSSE } from '@/lib/SSEContext'

interface RewardsData {
  pendingBNB: string
  pendingBNBFormatted: string
  pendingBEAN: {
    unrefined: string
    unrefinedFormatted: string
    refined: string
    refinedFormatted: string
    gross: string
    grossFormatted: string
    fee: string
    feeFormatted: string
    net: string
    netFormatted: string
  }
  uncheckpointedRound: string
}

interface ClaimRewardsProps {
  userAddress?: string
  onClaimBNB: () => void
  onClaimBEAN: () => void
}

const BnbLogo = ({ size = 16 }: { size?: number }) => (
  <img
    src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
    alt="BNB"
    style={{ width: size, height: size, objectFit: "contain" as const }}
  />
)

const BeanIcon = ({ size = 16 }: { size?: number }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill="#F0B90B">
    <ellipse cx="12" cy="12" rx="8" ry="10" />
  </svg>
)

export default function ClaimRewards({ userAddress, onClaimBNB, onClaimBEAN }: ClaimRewardsProps) {
  const [rewards, setRewards] = useState<RewardsData | null>(null)
  const { subscribeUser } = useSSE()

  const fetchRewards = useCallback(() => {
    if (!userAddress) return
    apiFetch<RewardsData>(`/api/user/${userAddress}/rewards`)
      .then(data => setRewards(data))
      .catch(() => {})
  }, [userAddress])

  // Fetch on mount and when address changes
  useEffect(() => {
    fetchRewards()
  }, [fetchRewards])

  // Re-fetch after settlement animation completes
  useEffect(() => {
    const handler = () => fetchRewards()
    window.addEventListener("settlementComplete", handler)
    return () => window.removeEventListener("settlementComplete", handler)
  }, [fetchRewards])

  // Subscribe to user SSE for claim confirmations
  useEffect(() => {
    const unsubBNB = subscribeUser('claimedBNB', () => fetchRewards())
    const unsubBEAN = subscribeUser('claimedBEAN', () => fetchRewards())
    return () => {
      unsubBNB()
      unsubBEAN()
    }
  }, [subscribeUser, fetchRewards])

  if (!userAddress || !rewards) return null

  const hasBNB = rewards.pendingBNB !== "0"
  const hasBEAN = rewards.pendingBEAN.gross !== "0"
  if (!hasBNB && !hasBEAN) return null

  const hasUnrefined = rewards.pendingBEAN.unrefined !== "0"
  const hasRefined = rewards.pendingBEAN.refined !== "0"

  return (
    <div style={styles.card}>
      <div style={styles.header}>Rewards</div>

      <div style={styles.rows}>
        <div style={styles.row}>
          <div style={styles.rowLabel}>
            <BnbLogo size={16} />
            <span>BNB Rewards</span>
          </div>
          <div style={{ ...styles.rowValue, color: hasBNB ? "#fff" : "#555" }}>
            {parseFloat(rewards.pendingBNBFormatted).toFixed(6)} BNB
          </div>
        </div>

        <div style={styles.row}>
          <div style={styles.rowLabel}>
            <BeanIcon size={16} />
            <span>Unrefined BEAN</span>
          </div>
          <div style={{ ...styles.rowValue, color: hasUnrefined ? "#fff" : "#555" }}>
            {parseFloat(rewards.pendingBEAN.unrefinedFormatted).toFixed(4)} BEAN
          </div>
        </div>

        <div style={styles.row}>
          <div style={styles.rowLabel}>
            <BeanIcon size={16} />
            <span>Refined BEAN</span>
          </div>
          <div style={{ ...styles.rowValue, color: hasRefined ? "#fff" : "#555" }}>
            {parseFloat(rewards.pendingBEAN.refinedFormatted).toFixed(4)} BEAN
          </div>
        </div>
      </div>

      <div style={styles.buttons}>
        <button
          style={hasBEAN ? styles.btnActive : styles.btnDisabled}
          disabled={!hasBEAN}
          onClick={onClaimBEAN}
        >
          Claim BEAN
        </button>
        <button
          style={hasBNB ? styles.btnActive : styles.btnDisabled}
          disabled={!hasBNB}
          onClick={onClaimBNB}
        >
          Claim BNB
        </button>
      </div>
    </div>
  )
}

const styles: { [key: string]: React.CSSProperties } = {
  card: {
    background: "#111",
    border: "1px solid #222",
    borderRadius: 12,
    padding: 16,
    marginTop: 12,
  },
  header: {
    fontSize: 14,
    fontWeight: 700,
    color: "#fff",
    marginBottom: 12,
  },
  rows: {
    display: "flex",
    flexDirection: "column",
    gap: 10,
  },
  row: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  rowLabel: {
    display: "flex",
    alignItems: "center",
    gap: 8,
    fontSize: 13,
    color: "#888",
  },
  rowValue: {
    fontSize: 13,
    fontWeight: 600,
    fontFamily: "'Inter', -apple-system, sans-serif",
  },
  buttons: {
    display: "flex",
    gap: 8,
    marginTop: 14,
  },
  btnActive: {
    flex: 1,
    padding: "10px 0",
    background: "#F0B90B",
    color: "#000",
    border: "none",
    borderRadius: 8,
    fontSize: 13,
    fontWeight: 700,
    cursor: "pointer",
  },
  btnDisabled: {
    flex: 1,
    padding: "10px 0",
    background: "#222",
    color: "#555",
    border: "none",
    borderRadius: 8,
    fontSize: 13,
    fontWeight: 700,
    cursor: "default",
  },
}

=== ./components/GlobalStats.tsx ===
'use client'

import React, { useState, useEffect } from "react"
import BeanLogo from './BeanLogo'
import { apiFetch } from '../lib/api'

// API response interfaces
interface StatsResponse {
    totalSupply: string
    totalSupplyFormatted: string
}

interface TreasuryStatsResponse {
    totalVaulted: string
    totalVaultedFormatted: string
    totalBurned: string
    totalBurnedFormatted: string
}

// Contract constant
const MAX_SUPPLY = 3_000_000

interface GlobalStatsProps {
    isMobile?: boolean
}

export default function GlobalStats({
    isMobile = false,
}: GlobalStatsProps) {
    const [mounted, setMounted] = useState(false)
    const [data, setData] = useState<{
        circulatingSupply: number
        burned: number
        protocolRevenue: number
    } | null>(null)

    useEffect(() => {
        setMounted(true)
    }, [])

    useEffect(() => {
        if (!mounted) return

        const fetchStats = async () => {
            try {
                const [statsRes, treasuryRes] = await Promise.all([
                    apiFetch<StatsResponse>('/api/stats'),
                    apiFetch<TreasuryStatsResponse>('/api/treasury/stats')
                ])
                setData({
                    circulatingSupply: parseFloat(statsRes.totalSupplyFormatted),
                    burned: parseFloat(treasuryRes.totalBurnedFormatted),
                    protocolRevenue: parseFloat(treasuryRes.totalVaultedFormatted)
                })
            } catch (err) {
                console.error('Failed to fetch stats:', err)
            }
        }
        fetchStats()
    }, [mounted])

    const stats = [
        {
            value: MAX_SUPPLY.toLocaleString(),
            label: "Max Supply",
            iconType: "beans",
        },
        {
            value: data?.circulatingSupply != null
                ? Math.floor(data.circulatingSupply).toLocaleString()
                : "—",
            label: "Circulating Supply",
            iconType: "beans",
        },
        {
            value: data?.burned != null
                ? Math.floor(data.burned).toLocaleString()
                : "—",
            label: "Burned",
            iconType: "beans",
        },
        {
            value: data?.protocolRevenue != null
                ? data.protocolRevenue.toLocaleString(undefined, { minimumFractionDigits: 4, maximumFractionDigits: 4 })
                : "—",
            label: "Protocol Revenue",
            iconType: "bnb",
        },
    ]

    // Return null until mounted to prevent hydration mismatch
    if (!mounted) {
        return null
    }

    if (isMobile) {
        return (
            <div style={styles.mobileWrapper}>
                <div style={styles.mobileHeader}>
                    <h1 style={styles.mobileTitle}>Global</h1>
                    <p style={styles.mobileSubtitle}>Review protocol stats and activity.</p>
                </div>

                <div style={styles.mobileGrid}>
                    {stats.map((stat, index) => (
                        <div key={index} style={styles.mobileStatBox}>
                            <div style={styles.mobileStatValue}>
                                {stat.iconType === "beans" && <BeanLogo size={14} />}
                                {stat.iconType === "bnb" && (
                                    <img
                                        src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
                                        alt="BNB"
                                        style={styles.mobileIcon}
                                    />
                                )}
                                <span>{stat.value}</span>
                            </div>
                            <div style={styles.mobileStatLabel}>{stat.label}</div>
                        </div>
                    ))}
                </div>
            </div>
        )
    }

    return (
        <div style={styles.wrapper}>
            <div style={styles.header}>
                <h1 style={styles.title}>Global</h1>
                <p style={styles.subtitle}>
                    Review protocol stats and activity.
                </p>
            </div>

            <div style={styles.container}>
                {stats.map((stat, index) => (
                    <div key={index} style={styles.statBox}>
                        <div style={styles.statValue}>
                            {stat.iconType === "beans" && <BeanLogo size={20} />}
                            {stat.iconType === "bnb" && (
                                <img
                                    src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
                                    alt="BNB"
                                    style={styles.bnbIcon}
                                />
                            )}
                            <span>{stat.value}</span>
                        </div>
                        <div style={styles.statLabel}>{stat.label}</div>
                    </div>
                ))}
            </div>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    wrapper: {
        paddingTop: "40px",
        paddingBottom: "20px",
    },
    header: {
        marginBottom: "32px",
    },
    title: {
        fontSize: "36px",
        fontWeight: 700,
        color: "#fff",
        margin: 0,
        marginBottom: "8px",
    },
    subtitle: {
        fontSize: "16px",
        color: "#666",
        margin: 0,
    },
    container: {
        display: "grid",
        gridTemplateColumns: "repeat(4, 1fr)",
        gap: "16px",
        marginBottom: "40px",
    },
    statBox: {
        background: "transparent",
        border: "1px solid #222",
        borderRadius: "12px",
        padding: "24px 20px",
        textAlign: "center" as const,
    },
    statValue: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "8px",
        fontSize: "22px",
        fontWeight: 600,
        color: "#fff",
        marginBottom: "10px",
    },
    bnbIcon: {
        width: "22px",
        height: "22px",
        objectFit: "contain" as const,
    },
    statLabel: {
        fontSize: "14px",
        color: "#666",
    },
    mobileWrapper: {
        paddingBottom: "16px",
    },
    mobileHeader: {
        marginBottom: "12px",
    },
    mobileTitle: {
        fontSize: "20px",
        fontWeight: 700,
        color: "#fff",
        margin: 0,
        marginBottom: "4px",
    },
    mobileSubtitle: {
        fontSize: "12px",
        color: "#666",
        margin: 0,
    },
    mobileGrid: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "8px",
    },
    mobileStatBox: {
        background: "transparent",
        border: "1px solid #222",
        borderRadius: "10px",
        padding: "12px 10px",
        textAlign: "center" as const,
    },
    mobileStatValue: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "5px",
        fontSize: "15px",
        fontWeight: 600,
        color: "#fff",
        marginBottom: "4px",
    },
    mobileIcon: {
        width: "14px",
        height: "14px",
        objectFit: "contain" as const,
    },
    mobileStatLabel: {
        fontSize: "10px",
        color: "#666",
    },
}

=== ./components/Header.tsx ===
'use client'

import React, { useState, useEffect } from 'react'
import { ConnectButton } from '@rainbow-me/rainbowkit'
import WalletButton from './WalletButton'
import BeanLogo, { BeansTextLogo } from './BeanLogo'
import Link from 'next/link'

interface HeaderProps {
  logoText?: string
  currentPage?: string
  isMobile?: boolean
}

export default function Header({
  logoText = 'BEANS',
  currentPage = 'home',
  isMobile: propIsMobile,
}: HeaderProps) {
  const [hoveredTab, setHoveredTab] = useState<string | null>(null)
  const [bnbPrice, setBnbPrice] = useState<string>('--')
  const [beansPrice, setBeansPrice] = useState<string>('--')
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => setIsMobile(propIsMobile ?? window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [propIsMobile])

  useEffect(() => {
    const fetchBnbPrice = async () => {
      try {
        const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT')
        const data = await response.json()
        if (data.price) setBnbPrice(parseFloat(data.price).toFixed(2))
      } catch (error) {
        setBnbPrice('580.00')
      }
    }
    fetchBnbPrice()
    const interval = setInterval(fetchBnbPrice, 10000)
    return () => clearInterval(interval)
  }, [])

  useEffect(() => {
    const fetchBeansPrice = async () => {
      try {
        const response = await fetch('https://api.dexscreener.com/latest/dex/pairs/bsc/0x7e58f160b5b77b8b24cd9900c09a3e730215ac47')
        const data = await response.json()
        if (data.pair?.priceUsd) setBeansPrice(parseFloat(data.pair.priceUsd).toFixed(4))
      } catch (error) {
        setBeansPrice('0.0264')
      }
    }
    fetchBeansPrice()
    const interval = setInterval(fetchBeansPrice, 30000)
    return () => clearInterval(interval)
  }, [])

  const tabs = [
    { id: 'about', label: 'About', href: '/about' },
    { id: 'global', label: 'Global', href: '/global' },
    { id: 'stake', label: 'Stake', href: '/stake' },
  ]

  if (isMobile) {
    return (
      <header style={styles.mobileHeader}>
        <Link href="/" style={styles.logo}>
          <BeanLogo size={24} />
          <BeansTextLogo height={20} />
        </Link>
        
        <div style={styles.mobileRight}>
          <div style={styles.mobileSocials}>
            <a href="#" style={styles.socialLink}>
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
              </svg>
            </a>
            <a href="#" style={styles.socialLink}>
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z" />
              </svg>
            </a>
            <a href="#" style={styles.socialLink}>
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z" />
              </svg>
            </a>
          </div>

          <ConnectButton 
            chainStatus="none"
            showBalance={false}
            accountStatus="avatar"
          />
        </div>
      </header>
    )
  }

  return (
    <header style={styles.header}>
      <div style={styles.logoSection}>
        <Link href="/" style={styles.logo}>
          <BeanLogo size={24} />
          <BeansTextLogo height={22} />
        </Link>

        <nav style={styles.nav}>
          {tabs.map((tab) => {
            const isHovered = hoveredTab === tab.id
            const isActive = currentPage === tab.id
            return (
              <Link
                key={tab.id}
                href={tab.href}
                style={{
                  ...styles.navItem,
                  color: isHovered || isActive ? '#fff' : '#666',
                }}
                onMouseEnter={() => setHoveredTab(tab.id)}
                onMouseLeave={() => setHoveredTab(null)}
              >
                <span>{tab.label}</span>
                <div
                  style={{
                    ...styles.navUnderline,
                    opacity: isHovered || isActive ? 1 : 0,
                    boxShadow: isHovered || isActive ? '0 0 8px 2px rgba(240, 185, 11, 0.5)' : 'none',
                  }}
                />
              </Link>
            )
          })}
        </nav>
      </div>

      <div style={styles.headerRight}>
        <div style={styles.priceTag}>
          <BeanLogo size={18} />
          <span style={styles.priceSymbol}>BEANS</span>
          <span style={styles.priceValue}>${beansPrice}</span>
        </div>

        <div style={styles.priceTag}>
          <img
            src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
            alt="BNB"
            style={styles.bnbLogo}
          />
          <span style={styles.priceSymbol}>BNB</span>
          <span style={styles.priceValue}>${bnbPrice}</span>
        </div>

        <div style={styles.socials}>
          <a href="#" style={styles.socialLink} target="_blank" rel="noopener noreferrer">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
            </svg>
          </a>
          <a href="#" style={styles.socialLink} target="_blank" rel="noopener noreferrer">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z" />
            </svg>
          </a>
          <a href="#" style={styles.socialLink} target="_blank" rel="noopener noreferrer">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z" />
            </svg>
          </a>
        </div>

        <WalletButton />
      </div>
    </header>
  )
}

const styles: { [key: string]: React.CSSProperties } = {
  mobileHeader: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: '12px 16px',
    borderBottom: '1px solid #1a1a1a',
    background: '#0a0a0a',
    fontFamily: "'Inter', -apple-system, sans-serif",
  },
  mobileRight: {
    display: 'flex',
    alignItems: 'center',
    gap: '16px',
  },
  mobileSocials: {
    display: 'flex',
    alignItems: 'center',
    gap: '12px',
  },
  header: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: '16px 40px',
    borderBottom: '1px solid #1a1a1a',
    background: '#0a0a0a',
    fontFamily: "'Inter', -apple-system, sans-serif",
  },
  logoSection: {
    display: 'flex',
    alignItems: 'center',
    gap: '40px',
  },
  logo: {
    display: 'flex',
    alignItems: 'center',
    gap: '10px',
    textDecoration: 'none',
  },
  nav: {
    display: 'flex',
    gap: '8px',
  },
  navItem: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '6px',
    padding: '8px 16px',
    fontSize: '14px',
    fontWeight: 500,
    cursor: 'pointer',
    transition: 'color 0.2s',
    textDecoration: 'none',
    position: 'relative',
  },
  navUnderline: {
    width: '100%',
    height: '2px',
    background: '#F0B90B',
    borderRadius: '1px',
    transition: 'opacity 0.2s, box-shadow 0.2s',
  },
  headerRight: {
    display: 'flex',
    alignItems: 'center',
    gap: '20px',
  },
  priceTag: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    fontSize: '14px',
    color: '#fff',
  },
  bnbLogo: {
    width: '18px',
    height: '18px',
    objectFit: 'contain' as const,
  },
  priceSymbol: {
    color: '#666',
  },
  priceValue: {
    color: '#fff',
    fontWeight: 500,
  },
  socials: {
    display: 'flex',
    gap: '16px',
    alignItems: 'center',
  },
  socialLink: {
    color: '#666',
    textDecoration: 'none',
    transition: 'color 0.15s',
    display: 'flex',
    alignItems: 'center',
  },
}

=== ./components/LandingPage.tsx ===
'use client'

import React, { useState, useEffect } from 'react'
import Link from 'next/link'
import WalletButton from './WalletButton'
import BeanLogo, { BeansTextLogo } from './BeanLogo'

interface LandingPageProps {
  onStartMining: () => void
}

export default function LandingPage({ onStartMining }: LandingPageProps) {
  const [bnbPrice, setBnbPrice] = useState<string>('--')
  const [beansPrice, setBeansPrice] = useState<string>('--')
  const [hoveredTab, setHoveredTab] = useState<string | null>(null)

  useEffect(() => {
    const fetchBnbPrice = async () => {
      try {
        const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT')
        const data = await response.json()
        if (data.price) setBnbPrice(parseFloat(data.price).toFixed(2))
      } catch (error) {
        setBnbPrice('580.00')
      }
    }
    fetchBnbPrice()
    const interval = setInterval(fetchBnbPrice, 10000)
    return () => clearInterval(interval)
  }, [])

  useEffect(() => {
    const fetchBeansPrice = async () => {
      try {
        const response = await fetch('https://api.dexscreener.com/latest/dex/pairs/bsc/0x7e58f160b5b77b8b24cd9900c09a3e730215ac47')
        const data = await response.json()
        if (data.pair?.priceUsd) setBeansPrice(parseFloat(data.pair.priceUsd).toFixed(4))
      } catch (error) {
        setBeansPrice('0.0264')
      }
    }
    fetchBeansPrice()
    const interval = setInterval(fetchBeansPrice, 30000)
    return () => clearInterval(interval)
  }, [])

  const tabs = [
    { id: 'about', label: 'About', href: '/about' },
    { id: 'global', label: 'Global', href: '/global' },
    { id: 'stake', label: 'Stake', href: '/stake' },
  ]

  return (
    <div style={styles.container}>
      <div style={styles.gridBackground} />
      <div style={styles.glowEffect} />
      
      <header style={styles.header}>
        <div style={styles.logoSection}>
          <Link href="/" style={styles.logo}>
            <BeanLogo size={24} />
            <BeansTextLogo height={22} />
          </Link>

          <nav style={styles.nav}>
            {tabs.map((tab) => {
              const isHovered = hoveredTab === tab.id
              return (
                <Link
                  key={tab.id}
                  href={tab.href}
                  style={{
                    ...styles.navItem,
                    color: isHovered ? '#fff' : '#666',
                  }}
                  onMouseEnter={() => setHoveredTab(tab.id)}
                  onMouseLeave={() => setHoveredTab(null)}
                >
                  <span>{tab.label}</span>
                  <div
                    style={{
                      ...styles.navUnderline,
                      opacity: isHovered ? 1 : 0,
                      boxShadow: isHovered ? '0 0 8px 2px rgba(240, 185, 11, 0.5)' : 'none',
                    }}
                  />
                </Link>
              )
            })}
          </nav>
        </div>

        <div style={styles.headerRight}>
          <div style={styles.priceTag}>
            <BeanLogo size={18} />
            <span style={styles.priceSymbol}>BEANS</span>
            <span style={styles.priceValue}>${beansPrice}</span>
          </div>

          <div style={styles.priceTag}>
            <img
              src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
              alt="BNB"
              style={styles.bnbLogo}
            />
            <span style={styles.priceSymbol}>BNB</span>
            <span style={styles.priceValue}>${bnbPrice}</span>
          </div>

          <div style={styles.socials}>
            <a href="#" style={styles.socialLink} target="_blank" rel="noopener noreferrer">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
              </svg>
            </a>
            <a href="#" style={styles.socialLink} target="_blank" rel="noopener noreferrer">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z" />
              </svg>
            </a>
            <a href="#" style={styles.socialLink} target="_blank" rel="noopener noreferrer">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z" />
              </svg>
            </a>
          </div>

          <WalletButton />
        </div>
      </header>
      
      <main style={styles.main}>
        <div style={styles.heroContent}>
          <div style={styles.beanLogoWrapper}>
            <div style={styles.beanLogoGlow} />
            <BeanLogo size={80} />
          </div>
          
          <h1 style={styles.headline}>The BSC Mining Game</h1>
          
          <p style={styles.subheadline}>
            Deploy BNB. Compete for blocks. Win rewards every 60 seconds.
          </p>
          
          <div style={styles.ctaContainer}>
            <button style={styles.primaryCta} onClick={onStartMining}>
              Start Mining
            </button>
            <Link href="/about" style={styles.secondaryCta}>
              Learn More
            </Link>
          </div>
        </div>
      </main>
    </div>
  )
}

const styles: { [key: string]: React.CSSProperties } = {
  container: { minHeight: '100vh', background: '#0a0a0a', position: 'relative', overflow: 'hidden', fontFamily: "'Inter', -apple-system, sans-serif" },
  gridBackground: { position: 'absolute', inset: 0, backgroundImage: 'linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px)', backgroundSize: '60px 60px' },
  glowEffect: { position: 'absolute', top: '30%', left: '50%', transform: 'translate(-50%, -50%)', width: '600px', height: '400px', background: 'radial-gradient(ellipse, rgba(240, 185, 11, 0.15) 0%, transparent 70%)', pointerEvents: 'none' },
  header: { position: 'relative', display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '16px 40px', borderBottom: '1px solid #1a1a1a', zIndex: 10 },
  logoSection: { display: 'flex', alignItems: 'center', gap: '40px' },
  logo: { display: 'flex', alignItems: 'center', gap: '10px', textDecoration: 'none' },
  nav: { display: 'flex', gap: '8px' },
  navItem: { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '6px', padding: '8px 16px', fontSize: '14px', fontWeight: 500, cursor: 'pointer', transition: 'color 0.2s', textDecoration: 'none', position: 'relative' },
  navUnderline: { width: '100%', height: '2px', background: '#F0B90B', borderRadius: '1px', transition: 'opacity 0.2s, box-shadow 0.2s' },
  headerRight: { display: 'flex', alignItems: 'center', gap: '20px' },
  priceTag: { display: 'flex', alignItems: 'center', gap: '8px', fontSize: '14px', color: '#fff' },
  bnbLogo: { width: '18px', height: '18px', objectFit: 'contain' as const },
  priceSymbol: { color: '#666' },
  priceValue: { color: '#fff', fontWeight: 500 },
  socials: { display: 'flex', gap: '16px', alignItems: 'center' },
  socialLink: { color: '#666', textDecoration: 'none', transition: 'color 0.15s', display: 'flex', alignItems: 'center' },
  main: { position: 'relative', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', minHeight: 'calc(100vh - 80px)', padding: '0 24px', zIndex: 10 },
  heroContent: { display: 'flex', flexDirection: 'column', alignItems: 'center', textAlign: 'center', marginTop: '-60px' },
  beanLogoWrapper: { position: 'relative', marginBottom: '40px' },
  beanLogoGlow: { position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', width: '160px', height: '160px', background: 'radial-gradient(circle, rgba(240, 185, 11, 0.3) 0%, transparent 70%)', pointerEvents: 'none' },
  headline: { fontSize: '64px', fontWeight: 700, color: '#fff', margin: '0 0 20px 0', letterSpacing: '-2px', lineHeight: 1.1 },
  subheadline: { fontSize: '20px', color: '#666', margin: '0 0 48px 0', maxWidth: '500px', lineHeight: 1.5 },
  ctaContainer: { display: 'flex', gap: '16px' },
  primaryCta: { background: '#F0B90B', color: '#000', border: 'none', borderRadius: '8px', padding: '16px 48px', fontSize: '16px', fontWeight: 600, cursor: 'pointer' },
  secondaryCta: { background: 'transparent', color: '#fff', border: '1px solid #333', borderRadius: '8px', padding: '16px 48px', fontSize: '16px', fontWeight: 500, textDecoration: 'none', display: 'flex', alignItems: 'center', justifyContent: 'center' },
}

=== ./components/LeaderboardTable.tsx ===
'use client'

import React, { useState, useEffect } from "react"
import BeanLogo from "./BeanLogo"
import { apiFetch } from '../lib/api'

// Display interface
interface LeaderboardEntry {
    rank: number
    address: string
    value: number
}

// API response interfaces
interface DeployerFromAPI {
    address: string
    totalDeployed: string
    totalDeployedFormatted: string
    roundsPlayed: number
}

interface EarnerFromAPI {
    address: string
    unclaimed: string
    unclaimedFormatted: string
}

interface MinersResponse {
    period: string
    deployers: DeployerFromAPI[]
}

interface EarnersResponse {
    earners: EarnerFromAPI[]
    pagination: { page: number; limit: number; total: number; pages: number }
}

// Helper functions
const formatAddress = (addr: string): string => {
    if (!addr || addr.length < 10) return addr
    return `${addr.slice(0, 6)}...${addr.slice(-4)}`
}

const transformDeployer = (d: DeployerFromAPI, i: number): LeaderboardEntry => ({
    rank: i + 1,
    address: formatAddress(d.address),
    value: parseFloat(d.totalDeployedFormatted)
})

const transformEarner = (e: EarnerFromAPI, i: number): LeaderboardEntry => ({
    rank: i + 1,
    address: formatAddress(e.address),
    value: parseFloat(e.unclaimedFormatted)
})

// SVG Icons
const BnbIcon = () => (
    <img
        src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
        alt="BNB"
        style={{ width: 16, height: 16, objectFit: "contain" as const }}
    />
)

export default function LeaderboardTable() {
    const [activeTab, setActiveTab] = useState<"miners" | "stakers" | "unrefined">("miners")
    const [miners, setMiners] = useState<LeaderboardEntry[]>([])
    const [unrefined, setUnrefined] = useState<LeaderboardEntry[]>([])
    const [loading, setLoading] = useState(true)
    const [isMobile, setIsMobile] = useState(false)
    const [mounted, setMounted] = useState(false)

    useEffect(() => {
        setMounted(true)
    }, [])

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768)
        checkMobile()
        window.addEventListener('resize', checkMobile)
        return () => window.removeEventListener('resize', checkMobile)
    }, [])

    useEffect(() => {
        if (!mounted) return

        const fetchData = async () => {
            setLoading(true)
            try {
                const [minersRes, earnersRes] = await Promise.all([
                    apiFetch<MinersResponse>('/api/leaderboard/miners?period=all&limit=12'),
                    apiFetch<EarnersResponse>('/api/leaderboard/earners?limit=12')
                ])
                setMiners(minersRes.deployers.map(transformDeployer))
                setUnrefined(earnersRes.earners.map(transformEarner))
            } catch (err) {
                console.error('Failed to fetch leaderboard:', err)
            } finally {
                setLoading(false)
            }
        }
        fetchData()
    }, [mounted])

    const tabs = [
        {
            id: "miners",
            label: "Miners",
            icon: (
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66.19-.34.05-.08.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21z" />
                </svg>
            ),
        },
        {
            id: "stakers",
            label: "Stakers",
            icon: (
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z" />
                </svg>
            ),
        },
        {
            id: "unrefined",
            label: "Unrefined",
            icon: (
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1zm-4.44-6.19l-2.35 3.02-1.56-1.88c-.2-.25-.58-.24-.78.01l-1.74 2.23c-.26.33-.02.81.39.81h8.98c.41 0 .65-.47.4-.8l-2.55-3.39c-.19-.26-.59-.26-.79 0z" />
                </svg>
            ),
        },
    ]

    const getDescription = () => {
        switch (activeTab) {
            case "miners":
                return "Top miners by total BNB deployed over their lifetime."
            case "stakers":
                return "Top stakers by amount of BEANS staked."
            case "unrefined":
                return "Top miners by amount of unrefined BEANS."
        }
    }

    const getColumnHeader = () => {
        switch (activeTab) {
            case "miners":
                return "Total Deployed"
            case "stakers":
                return "Staked"
            case "unrefined":
                return "Unrefined"
        }
    }

    const getData = (): LeaderboardEntry[] => {
        switch (activeTab) {
            case "miners":
                return miners
            case "stakers":
                return [] // Coming soon
            case "unrefined":
                return unrefined
        }
    }

    const getValueIcon = () => {
        switch (activeTab) {
            case "miners":
                return "bnb"
            case "stakers":
                return "beans"
            case "unrefined":
                return "beans"
        }
    }

    // Return null until mounted to prevent hydration mismatch
    if (!mounted) {
        return null
    }

    return (
        <div style={isMobile ? styles.containerMobile : styles.container}>
            <h2 style={isMobile ? styles.titleMobile : styles.title}>Leaderboard</h2>

            {/* Tabs */}
            <div style={isMobile ? styles.tabsMobile : styles.tabs}>
                {tabs.map((tab) => (
                    <button
                        key={tab.id}
                        style={{
                            ...(isMobile ? styles.tabMobile : styles.tab),
                            ...(activeTab === tab.id ? styles.tabActive : {}),
                        }}
                        onClick={() => setActiveTab(tab.id as any)}
                    >
                        {tab.icon}
                        {tab.label}
                    </button>
                ))}
            </div>

            {/* Description */}
            <p style={isMobile ? styles.descriptionMobile : styles.description}>{getDescription()}</p>

            {/* Table or Empty State */}
            {activeTab === "stakers" ? (
                <div style={styles.emptyState}>
                    <p style={styles.emptyText}>Staking leaderboard coming soon</p>
                </div>
            ) : loading && getData().length === 0 ? (
                <div style={styles.emptyState}>
                    <p style={styles.emptyText}>Loading...</p>
                </div>
            ) : getData().length === 0 ? (
                <div style={styles.emptyState}>
                    <p style={styles.emptyText}>No data available</p>
                </div>
            ) : (
                <div style={styles.tableWrapper}>
                    <table style={styles.table}>
                        <thead>
                            <tr>
                                <th style={styles.th}>Rank</th>
                                <th style={styles.th}>Address</th>
                                <th style={styles.thRight}>{getColumnHeader()}</th>
                            </tr>
                        </thead>
                        <tbody>
                            {getData().map((entry, index) => (
                                <tr key={index} style={styles.tr}>
                                    <td style={styles.td}>#{entry.rank}</td>
                                    <td style={styles.td}>
                                        <span>{entry.address}</span>
                                    </td>
                                    <td style={styles.tdRight}>
                                        {getValueIcon() === "bnb" ? (
                                            <span style={styles.valueWithIcon}>
                                                <BnbIcon />
                                                {entry.value.toLocaleString(undefined, { maximumFractionDigits: 4 })}
                                            </span>
                                        ) : (
                                            <span style={styles.valueWithIcon}>
                                                <BeanLogo size={16} />
                                                {entry.value.toLocaleString(undefined, { maximumFractionDigits: 4 })}
                                            </span>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        marginBottom: "48px",
    },
    containerMobile: {
        marginBottom: "32px",
    },
    title: {
        fontSize: "24px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "20px",
    },
    titleMobile: {
        fontSize: "18px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "12px",
    },
    tabs: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr 1fr",
        gap: "8px",
        marginBottom: "16px",
    },
    tabsMobile: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr 1fr",
        gap: "6px",
        marginBottom: "12px",
    },
    tab: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "8px",
        background: "transparent",
        border: "none",
        borderRadius: "8px",
        padding: "12px 24px",
        fontSize: "14px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    tabMobile: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "5px",
        background: "transparent",
        border: "none",
        borderRadius: "8px",
        padding: "10px 8px",
        fontSize: "12px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    tabActive: {
        background: "#222",
        color: "#fff",
    },
    description: {
        fontSize: "14px",
        color: "#666",
        margin: 0,
        marginBottom: "24px",
    },
    descriptionMobile: {
        fontSize: "12px",
        color: "#666",
        margin: 0,
        marginBottom: "16px",
    },
    tableWrapper: {
        overflowX: "auto",
    },
    table: {
        width: "100%",
        borderCollapse: "collapse",
        minWidth: "350px",
    },
    th: {
        textAlign: "left" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
        whiteSpace: "nowrap" as const,
    },
    thRight: {
        textAlign: "right" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
        whiteSpace: "nowrap" as const,
    },
    tr: {
        borderBottom: "1px solid #111",
    },
    td: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        whiteSpace: "nowrap" as const,
    },
    tdRight: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        textAlign: "right" as const,
        whiteSpace: "nowrap" as const,
    },
    valueWithIcon: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: "6px",
    },
    emptyState: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        padding: "48px 24px",
        background: "#111",
        borderRadius: "8px",
    },
    emptyText: {
        fontSize: "14px",
        color: "#666",
        margin: 0,
    },
}

=== ./components/MinersPanel.tsx ===
'use client'

import React, { useState, useEffect, useRef, useCallback } from "react"
import { apiFetch } from "@/lib/api"

interface Miner {
    address: string
    bnbRewardFormatted: string
    beanRewardFormatted: string
    deployedFormatted: string
}

interface MinersResponse {
    roundId: number
    winningBlock: number
    miners: Miner[]
}

function truncateAddress(address: string): string {
    if (address.length <= 13) return address
    return `${address.slice(0, 6)}...${address.slice(-4)}`
}

export default function MinersPanel() {
    const [isOpen, setIsOpen] = useState(false)
    const [isHoveringTab, setIsHoveringTab] = useState(false)
    const [miners, setMiners] = useState<Miner[]>([])
    const [roundId, setRoundId] = useState<number | null>(null)
    const [winningBlock, setWinningBlock] = useState<number | null>(null)
    const [loading, setLoading] = useState(false)

    // Store settled roundId so we can fetch miners after animation completes
    const settledRoundIdRef = useRef<string | null>(null)

    const fetchMiners = useCallback((id: string) => {
        setLoading(true)
        apiFetch<MinersResponse>(`/api/round/${id}/miners`)
            .then((data) => {
                if (data.miners.length > 0) {
                    setMiners(data.miners)
                    setRoundId(data.roundId)
                    setWinningBlock(data.winningBlock)
                    setIsOpen(true)
                }
                // If no miners (empty round), keep showing previous round's data
                // but don't open the panel — it stays as-is
            })
            .catch((err) => console.error('Failed to fetch miners:', err))
            .finally(() => setLoading(false))
    }, [])

    // Listen for roundSettled → store the settled roundId (consumed once by settlementComplete)
    useEffect(() => {
        const handleRoundSettled = (event: CustomEvent) => {
            const { roundId: settledId } = event.detail
            settledRoundIdRef.current = settledId
        }

        window.addEventListener("roundSettled" as any, handleRoundSettled)
        return () => window.removeEventListener("roundSettled" as any, handleRoundSettled)
    }, [])

    // Listen for settlementComplete → fetch miners for the settled round
    useEffect(() => {
        const handleSettlementComplete = () => {
            if (settledRoundIdRef.current) {
                fetchMiners(settledRoundIdRef.current)
                settledRoundIdRef.current = null
            }
        }

        window.addEventListener("settlementComplete", handleSettlementComplete)
        return () => window.removeEventListener("settlementComplete", handleSettlementComplete)
    }, [fetchMiners])

    // Don't show tab if no miners data yet
    const hasData = miners.length > 0

    return (
        <>
            {/* Collapsed Tab - Attached to left edge */}
            {!isOpen && hasData && (
                <div
                    style={{
                        ...styles.tab,
                        borderWidth: isHoveringTab ? "2px" : "1px",
                    }}
                    onClick={() => setIsOpen(true)}
                    onMouseEnter={() => setIsHoveringTab(true)}
                    onMouseLeave={() => setIsHoveringTab(false)}
                >
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="#666">
                        <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z" />
                    </svg>
                </div>
            )}

            {/* Expanded Panel */}
            <div
                style={{
                    ...styles.panel,
                    ...(isOpen ? styles.panelOpen : styles.panelClosed),
                }}
            >
                {/* Panel Header */}
                <div style={styles.panelHeader}>
                    <span style={styles.panelTitle}>Winners</span>
                    <button
                        style={styles.closeBtn}
                        onClick={() => setIsOpen(false)}
                    >
                        ✕
                    </button>
                </div>

                {/* Round Info */}
                <div style={styles.roundInfo}>
                    <span style={styles.roundLabel}>
                        Round #{roundId}{winningBlock !== null ? ` · Block #${winningBlock + 1}` : ''}
                    </span>
                    <span style={styles.minerCount}>
                        {miners.length} winner{miners.length !== 1 ? 's' : ''}
                    </span>
                </div>

                {/* Miners List */}
                <div style={styles.minersList}>
                    {loading ? (
                        <div style={styles.emptyState}>Loading...</div>
                    ) : miners.length === 0 ? (
                        <div style={styles.emptyState}>No miners data</div>
                    ) : (
                        miners.map((miner, index) => (
                            <div key={index} style={styles.minerRow}>
                                <span style={styles.minerAddress}>
                                    {truncateAddress(miner.address)}
                                </span>
                                <div style={styles.minerAmounts}>
                                    <span style={styles.bnbAmount}>
                                        <img src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public" alt="BNB" style={{width: 14, height: 14, marginRight: 4}} />
                                        {parseFloat(miner.bnbRewardFormatted).toFixed(6)}
                                    </span>
                                    {parseFloat(miner.beanRewardFormatted) > 0 && (
                                        <>
                                            <span style={styles.plusSign}>+</span>
                                            <span style={styles.beansAmount}>
                                                🫘 {parseFloat(miner.beanRewardFormatted).toFixed(4)}
                                            </span>
                                        </>
                                    )}
                                </div>
                            </div>
                        ))
                    )}
                </div>
            </div>

            {/* Overlay to close when clicking outside */}
            {isOpen && (
                <div style={styles.overlay} onClick={() => setIsOpen(false)} />
            )}
        </>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    // Collapsed Tab - Attached to left edge
    tab: {
        position: "fixed",
        left: 0,
        top: "100px",
        background: "#111",
        borderRadius: "0 8px 8px 0",
        padding: "14px 12px",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 100,
        transition: "border-width 0.15s ease",
        border: "1px solid #F0B90B",
        borderLeft: "none",
    },

    // Expanded Panel
    panel: {
        position: "fixed",
        left: 0,
        top: 0,
        bottom: 0,
        width: "360px",
        background: "#0a0a0a",
        borderRight: "1px solid #222",
        display: "flex",
        flexDirection: "column",
        zIndex: 101,
        transition: "transform 0.3s ease",
        fontFamily: "'Inter', -apple-system, sans-serif",
    },
    panelOpen: {
        transform: "translateX(0)",
    },
    panelClosed: {
        transform: "translateX(-100%)",
    },

    // Panel Header
    panelHeader: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "20px",
        borderBottom: "1px solid #222",
    },
    panelTitle: {
        fontSize: "18px",
        fontWeight: 600,
        color: "#fff",
    },
    closeBtn: {
        background: "transparent",
        border: "none",
        color: "#666",
        fontSize: "18px",
        cursor: "pointer",
        padding: "4px 8px",
        borderRadius: "4px",
        transition: "color 0.15s",
    },

    // Round Info
    roundInfo: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "16px 20px",
        borderBottom: "1px solid #1a1a1a",
    },
    roundLabel: {
        fontSize: "13px",
        color: "#666",
    },
    minerCount: {
        fontSize: "13px",
        color: "#666",
    },

    // Miners List
    minersList: {
        flex: 1,
        overflowY: "auto",
        padding: "8px 0",
    },
    minerRow: {
        display: "flex",
        flexDirection: "column",
        gap: "4px",
        padding: "12px 20px",
        borderBottom: "1px solid #111",
    },
    minerAddress: {
        fontSize: "14px",
        color: "#fff",
        fontFamily: "monospace",
    },
    minerAmounts: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
    },
    beansAmount: {
        fontSize: "13px",
        color: "#F0B90B",
        fontWeight: 500,
    },
    plusSign: {
        fontSize: "11px",
        color: "#444",
    },
    bnbAmount: {
        fontSize: "13px",
        color: "#888",
        display: "flex",
        alignItems: "center",
    },
    emptyState: {
        padding: "40px 20px",
        textAlign: "center",
        color: "#555",
        fontSize: "13px",
    },

    // Overlay
    overlay: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: "rgba(0,0,0,0.5)",
        zIndex: 100,
    },
}

=== ./components/MiningGrid.tsx ===
'use client'

import React, { useState, useEffect, useCallback, useRef } from "react"
import { apiFetch } from "@/lib/api"
import { useSSE } from "@/lib/SSEContext"

interface BlockData {
    id: number
    deployed: string
    deployedFormatted: string
    minerCount: number
}

interface RoundResponse {
    roundId: string
    startTime: number
    endTime: number
    totalDeployed: string
    totalDeployedFormatted: string
    motherlodePool: string
    motherlodePoolFormatted: string
    settled: boolean
    blocks: BlockData[]
    userDeployed?: string
    userDeployedFormatted?: string
}

interface DeployedEvent {
    roundId: string
    user: string
    totalAmount: string
    isAutoMine: boolean
    totalDeployed: string
    totalDeployedFormatted: string
    userDeployed: string
    userDeployedFormatted: string
    blocks: BlockData[]
}

interface RoundSettledEvent {
    roundId: string
    winningBlock: string
    topMiner: string
    totalWinnings: string
    topMinerReward: string
    motherlodeAmount: string
    isSplit: boolean
}

interface GameStartedEvent {
    roundId: string
    startTime: number
    endTime: number
    motherlodePool: string
    motherlodePoolFormatted: string
}

interface CellData {
    minerCount: number
    amount: number
}

interface MiningGridProps {
    selectedBlocks?: number[]
    onBlocksChange?: (blocks: number[]) => void
    userAddress?: string
}

function decodeBlockMask(mask: string): number[] {
    const n = BigInt(mask)
    const blocks: number[] = []
    for (let i = 0; i < 25; i++) {
        if ((n >> BigInt(i)) & BigInt(1)) blocks.push(i)
    }
    return blocks
}

function blocksToGrid(blocks: BlockData[]): CellData[] {
    return Array.from({ length: 25 }, (_, i) => {
        const block = blocks.find((b) => b.id === i)
        return {
            minerCount: block?.minerCount ?? 0,
            amount: block ? parseFloat(block.deployedFormatted) : 0,
        }
    })
}

export default function MiningGrid({
    selectedBlocks: externalSelectedBlocks,
    onBlocksChange,
    userAddress,
}: MiningGridProps) {
    const [internalSelectedBlocks, setInternalSelectedBlocks] = useState<number[]>([])
    const [phase, setPhase] = useState<"counting" | "eliminating" | "winner" | "miners">("counting")
    const [eliminatedBlocks, setEliminatedBlocks] = useState<number[]>([])
    const [winningBlock, setWinningBlock] = useState<number | null>(null)

    const selectedBlocks = externalSelectedBlocks ?? internalSelectedBlocks
    const setSelectedBlocks = (blocks: number[] | ((prev: number[]) => number[])) => {
        const newBlocks = typeof blocks === "function" ? blocks(selectedBlocks) : blocks
        if (onBlocksChange) {
            onBlocksChange(newBlocks)
        } else {
            setInternalSelectedBlocks(newBlocks)
        }
    }

    const [cells, setCells] = useState<CellData[]>(() =>
        Array.from({ length: 25 }, () => ({ minerCount: 0, amount: 0 }))
    )
    const [currentRoundId, setCurrentRoundId] = useState<string>("")
    const [userDeployedBlocks, setUserDeployedBlocks] = useState<Set<number>>(new Set())
    const [hasDeployedThisRound, setHasDeployedThisRound] = useState(false)
    const [autoMode, setAutoMode] = useState<{ enabled: boolean, strategy: "all" | "random" | null }>({ enabled: false, strategy: null })

    // Animation state: snapshot freezes grid data so resets can't wipe it mid-animation
    const animatingRef = useRef(false)
    const snapshotCellsRef = useRef<CellData[] | null>(null)
    const pendingResetRef = useRef<GameStartedEvent | null>(null)
    const animationTimers = useRef<ReturnType<typeof setTimeout>[]>([])
    // Keep a mutable ref to cells so the SSE closure always reads the latest value
    const cellsRef = useRef(cells)
    cellsRef.current = cells
    // Keep a mutable ref to userAddress so callbacks always read the latest value
    const userAddressRef = useRef(userAddress)
    userAddressRef.current = userAddress

    const clearAnimationTimers = useCallback(() => {
        animationTimers.current.forEach(clearTimeout)
        animationTimers.current = []
    }, [])

    const resetForNewRound = useCallback((eventData?: GameStartedEvent | null) => {
        clearAnimationTimers()
        snapshotCellsRef.current = null
        setPhase("counting")
        setEliminatedBlocks([])
        setWinningBlock(null)
        setSelectedBlocks([])
        setCells(Array.from({ length: 25 }, () => ({ minerCount: 0, amount: 0 })))
        setUserDeployedBlocks(new Set())
        setHasDeployedThisRound(false)
        animatingRef.current = false
        pendingResetRef.current = null
        window.dispatchEvent(new CustomEvent("settlementComplete"))

        if (eventData) {
            setCurrentRoundId(eventData.roundId)
            window.dispatchEvent(
                new CustomEvent("roundData", { detail: eventData })
            )
        }

        // Re-fetch current round to pick up any deployments that arrived during the animation
        const fetchUrl = userAddressRef.current
            ? `/api/round/current?user=${userAddressRef.current}`
            : '/api/round/current'
        apiFetch<RoundResponse>(fetchUrl)
            .then((round) => {
                if (animatingRef.current) return
                setCells(blocksToGrid(round.blocks))
                window.dispatchEvent(
                    new CustomEvent("roundData", { detail: round })
                )
            })
            .catch((err) => console.error('Failed to refresh round after animation:', err))
    }, [clearAnimationTimers])

    // Fetch initial round state
    useEffect(() => {
        const url = userAddress
            ? `/api/round/current?user=${userAddress}`
            : '/api/round/current'
        apiFetch<RoundResponse>(url)
            .then((round) => {
                if (animatingRef.current) return
                setCells(blocksToGrid(round.blocks))
                setCurrentRoundId(round.roundId)
                window.dispatchEvent(
                    new CustomEvent("roundData", { detail: round })
                )
            })
            .catch((err) => console.error('Failed to load round:', err))
    }, [userAddress])

    // Fetch user's deployed blocks for the current round
    useEffect(() => {
        if (!userAddress || !currentRoundId) return
        apiFetch<{ history: Array<{ roundId: number, blockMask: string }> }>(
            `/api/user/${userAddress}/history?type=deploy&roundId=${currentRoundId}`
        ).then(data => {
            const blocks = new Set<number>()
            for (const entry of data.history) {
                for (const id of decodeBlockMask(entry.blockMask)) {
                    blocks.add(id)
                }
            }
            setUserDeployedBlocks(blocks)
            if (blocks.size > 0) setHasDeployedThisRound(true)
        }).catch(() => {})
    }, [userAddress, currentRoundId])

    // Listen for optimistic deploy updates from page.tsx
    useEffect(() => {
        const handleUserDeployed = (event: CustomEvent) => {
            const { blockIds } = event.detail as { blockIds: number[] }
            setUserDeployedBlocks(prev => {
                const next = new Set(prev)
                blockIds.forEach(id => next.add(id))
                return next
            })
            // One deploy per round — lock the grid after deploy
            setHasDeployedThisRound(true)
            setSelectedBlocks([])
            window.dispatchEvent(new CustomEvent("blocksChanged", {
                detail: { blocks: [], count: 0 }
            }))
        }
        window.addEventListener("userDeployed" as any, handleUserDeployed)
        return () => window.removeEventListener("userDeployed" as any, handleUserDeployed)
    }, [])

    // Subscribe to user SSE for AutoMiner deployments via centralized SSE context
    const { subscribeUser, subscribeGlobal } = useSSE()

    useEffect(() => {
        return subscribeUser('autoMineExecuted', (data) => {
            const d = data as { roundId: string; blocks?: number[]; roundsExecuted: number }
            // Mark these blocks as deployed by user (guard against undefined blocks)
            if (d.blocks && d.blocks.length > 0) {
                setUserDeployedBlocks(prev => {
                    const next = new Set(prev)
                    d.blocks!.forEach(id => next.add(id))
                    return next
                })
                setHasDeployedThisRound(true)
                // Clear selection and notify controls
                setSelectedBlocks([])
                window.dispatchEvent(new CustomEvent("blocksChanged", {
                    detail: { blocks: [], count: 0 }
                }))
            }
        })
    }, [subscribeUser])

    // Subscribe to global SSE events for live updates via centralized SSE context
    useEffect(() => {
        const unsubDeployed = subscribeGlobal('deployed', (data) => {
            if (animatingRef.current) return
            const d = data as DeployedEvent
            setCells(blocksToGrid(d.blocks))

            // If this is the connected user's AutoMiner deployment, fetch their blocks
            // This handles the race condition where user SSE may not be connected yet
            if (d.isAutoMine && userAddressRef.current &&
                d.user.toLowerCase() === userAddressRef.current.toLowerCase()) {
                apiFetch<{ history: Array<{ blockMask: string }> }>(
                    `/api/user/${userAddressRef.current}/history?type=deploy&roundId=${d.roundId}&limit=1`
                ).then((res) => {
                    if (res.history[0]?.blockMask) {
                        const blockIds = decodeBlockMask(res.history[0].blockMask)
                        if (blockIds.length > 0) {
                            setUserDeployedBlocks(prev => {
                                const next = new Set(prev)
                                blockIds.forEach(id => next.add(id))
                                return next
                            })
                            setHasDeployedThisRound(true)
                            setSelectedBlocks([])
                            window.dispatchEvent(new CustomEvent("blocksChanged", {
                                detail: { blocks: [], count: 0 }
                            }))
                        }
                    }
                }).catch(() => {})
            }

            window.dispatchEvent(new CustomEvent("roundDeployed", {
                detail: {
                    totalDeployed: d.totalDeployed,
                    totalDeployedFormatted: d.totalDeployedFormatted,
                    user: d.user,
                    userDeployedFormatted: d.userDeployedFormatted,
                }
            }))
        })

        const unsubSettled = subscribeGlobal('roundSettled', (data) => {
            const d = data as RoundSettledEvent
            const winner = parseInt(d.winningBlock, 10)
            clearAnimationTimers()

            // Freeze current grid data so it survives any resets
            snapshotCellsRef.current = [...cellsRef.current]
            animatingRef.current = true
            setPhase("eliminating")
            setWinningBlock(winner)

            // Eliminate blocks one by one over 5 seconds
            const toEliminate = Array.from({ length: 25 }, (_, i) => i).filter((i) => i !== winner)
            toEliminate.sort(() => Math.random() - 0.5)

            const intervalTime = 5000 / toEliminate.length
            let eliminated: number[] = []

            toEliminate.forEach((blockIndex, i) => {
                const tid = setTimeout(() => {
                    eliminated = [...eliminated, blockIndex]
                    setEliminatedBlocks([...eliminated])
                }, intervalTime * (i + 1))
                animationTimers.current.push(tid)
            })

            // Show winner phase after elimination finishes (~5s)
            animationTimers.current.push(
                setTimeout(() => setPhase("winner"), 5200)
            )

            // After 3 more seconds of winner display (8s total), reset for the new round
            animationTimers.current.push(
                setTimeout(() => {
                    resetForNewRound(pendingResetRef.current)
                }, 8200)
            )

            window.dispatchEvent(
                new CustomEvent("roundSettled", { detail: d })
            )
        })

        const unsubGameStarted = subscribeGlobal('gameStarted', (data) => {
            const d = data as GameStartedEvent
            // Always buffer — never reset immediately.
            // If roundSettled already arrived, the animation timer handles the reset.
            // If roundSettled hasn't arrived yet (wrong order), wait 2s for it.
            pendingResetRef.current = d
            if (!animatingRef.current) {
                const fallbackId = setTimeout(() => {
                    if (!animatingRef.current) {
                        resetForNewRound(pendingResetRef.current)
                    }
                }, 2000)
                animationTimers.current.push(fallbackId)
            }
        })

        return () => {
            unsubDeployed()
            unsubSettled()
            unsubGameStarted()
            clearAnimationTimers()
        }
    }, [subscribeGlobal, resetForNewRound, clearAnimationTimers])

    // Listen for select-all from sidebar controls
    useEffect(() => {
        const handleSelectAll = (event: CustomEvent) => {
            if (hasDeployedThisRound) return
            const { selectAll } = event.detail
            if (selectAll) {
                const allBlocks = Array.from({ length: 25 }, (_, i) => i)
                    .filter(i => !userDeployedBlocks.has(i))
                setSelectedBlocks(allBlocks)
                window.dispatchEvent(new CustomEvent("blocksChanged", { detail: { blocks: allBlocks, count: allBlocks.length } }))
            } else {
                setSelectedBlocks([])
                window.dispatchEvent(new CustomEvent("blocksChanged", { detail: { blocks: [], count: 0 } }))
            }
        }

        window.addEventListener("selectAllBlocks" as any, handleSelectAll)
        return () => window.removeEventListener("selectAllBlocks" as any, handleSelectAll)
    }, [])

    // Listen for autoMinerMode from sidebar controls
    useEffect(() => {
        const handleAutoMode = (event: CustomEvent) => {
            const { enabled, strategy } = event.detail
            setAutoMode({ enabled, strategy })
            if (enabled && strategy === "all") {
                // Select all 25 blocks
                const allBlocks = Array.from({ length: 25 }, (_, i) => i).filter(i => !userDeployedBlocks.has(i))
                setSelectedBlocks(allBlocks)
                window.dispatchEvent(new CustomEvent("blocksChanged", { detail: { blocks: allBlocks, count: allBlocks.length } }))
            } else {
                // Clear selection for random or manual mode
                setSelectedBlocks([])
                window.dispatchEvent(new CustomEvent("blocksChanged", { detail: { blocks: [], count: 0 } }))
            }
        }

        window.addEventListener("autoMinerMode" as any, handleAutoMode)
        return () => window.removeEventListener("autoMinerMode" as any, handleAutoMode)
    }, [userDeployedBlocks])

    const handleBlockClick = (index: number) => {
        if (autoMode.enabled) return  // Disable clicks in any auto mode (both "all" and "random")
        if (phase !== "counting") return
        if (hasDeployedThisRound) return
        if (userDeployedBlocks.has(index)) return
        const newSelection = selectedBlocks.includes(index)
            ? selectedBlocks.filter((i) => i !== index)
            : [...selectedBlocks, index]
        setSelectedBlocks(newSelection)
        window.dispatchEvent(new CustomEvent("blocksChanged", { detail: { blocks: newSelection, count: newSelection.length } }))
    }

    // During animation, render from the frozen snapshot so resets don't wipe visible data
    const displayCells = snapshotCellsRef.current ?? cells

    return (
        <div className="mining-grid-container" style={styles.container}>
            <div className="mining-grid" style={styles.grid}>
                {displayCells.map((cell, index) => {
                    const isSelected = selectedBlocks.includes(index)
                    const isWinner = winningBlock === index
                    const isEliminated = eliminatedBlocks.includes(index)
                    const isDeployed = userDeployedBlocks.has(index)

                    return (
                        <button
                            key={index}
                            className="mining-cell"
                            style={{
                                ...styles.cell,
                                ...(isDeployed && !isEliminated ? styles.cellDeployed : {}),
                                ...(isSelected && !isEliminated && !isDeployed ? styles.cellSelected : {}),
                                ...(isEliminated ? styles.cellEliminated : {}),
                                ...(isWinner && phase === "winner" ? styles.cellWinner : {}),
                                ...(autoMode.enabled && autoMode.strategy === "random" && !isDeployed ? styles.cellDisabled : {}),
                            }}
                            onClick={() => handleBlockClick(index)}
                            disabled={phase !== "counting" || isDeployed || hasDeployedThisRound || autoMode.enabled}
                        >
                            {!isEliminated && (
                                <>
                                    <div className="cell-header" style={styles.cellHeader}>
                                        <span className="cell-id" style={styles.cellId}>#{index + 1}</span>
                                        {isDeployed ? (
                                            <span style={styles.deployedCheck}>✓</span>
                                        ) : cell.minerCount > 0 ? (
                                            <span style={styles.minerCount}>{cell.minerCount}</span>
                                        ) : null}
                                    </div>
                                    <div className="cell-amount" style={styles.cellAmount}>
                                        {cell.amount > 0 ? cell.amount.toFixed(4) : '—'}
                                    </div>
                                </>
                            )}
                        </button>
                    )
                })}
            </div>

            <style>{`
                @media (max-width: 768px) {
                    .mining-grid-container {
                        width: 100% !important;
                        overflow: hidden !important;
                        max-width: none !important;
                    }

                    .mining-grid {
                        grid-template-columns: repeat(5, 1fr) !important;
                        gap: 6px !important;
                        width: 100% !important;
                        max-width: none !important;
                    }

                    .mining-cell {
                        min-height: unset !important;
                        aspect-ratio: 1 !important;
                        padding: 6px !important;
                        border-radius: 8px !important;
                    }

                    .cell-id {
                        font-size: 10px !important;
                    }

                    .cell-amount {
                        font-size: 12px !important;
                    }
                }
            `}</style>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        display: "flex",
        flexDirection: "column",
        gap: "16px",
        fontFamily: "'Inter', -apple-system, sans-serif",
        width: "100%",
        maxWidth: "710px",
    },
    grid: {
        display: "grid",
        gridTemplateColumns: "repeat(5, 1fr)",
        gap: "10px",
        width: "100%",
        maxWidth: "710px",
    },
    cell: {
        aspectRatio: "1",
        background: "transparent",
        border: "2px solid #333",
        borderRadius: "10px",
        padding: "14px",
        cursor: "pointer",
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-between",
        fontFamily: "inherit",
        position: "relative",
        transition: "border-color 0.15s",
        outline: "none",
    },
    cellSelected: {
        border: "2px solid #F0B90B",
    },
    cellDeployed: {
        border: "2px solid #2d5a2d",
        cursor: "default",
        opacity: 0.7,
    },
    deployedCheck: {
        fontSize: "12px",
        fontWeight: 700,
        color: "#4a9a4a",
    },
    cellEliminated: {
        opacity: 0.2,
        transform: "scale(0.95)",
        border: "2px solid #222",
    },
    cellWinner: {
        border: "2px solid #F0B90B",
        boxShadow: "0 0 20px rgba(240, 185, 11, 0.3)",
    },
    cellDisabled: {
        opacity: 0.5,
        cursor: "not-allowed",
    },
    cellHeader: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "flex-start",
    },
    cellId: {
        fontSize: "12px",
        fontWeight: 600,
        color: "#666",
    },
    minerCount: {
        fontSize: "10px",
        fontWeight: 600,
        color: "#888",
    },
    cellAmount: {
        fontSize: "14px",
        fontWeight: 700,
        color: "#fff",
        textAlign: "right",
    },
}

=== ./components/MiningTable.tsx ===
'use client'

import React, { useState, useEffect } from "react"
import BeanLogo from './BeanLogo'
import { apiFetch } from '../lib/api'

// Display interface (for table rendering)
interface Round {
    round: number
    block: number
    winner: string
    winners: number
    deployed: number
    vaulted: number
    winnings: number
    goldenBean: number | null
    time: string
}

// API response interfaces
interface RoundFromAPI {
    roundId: number
    winningBlock: number
    beanWinner: string | null  // address that won BEAN reward (null if split round)
    isSplit: boolean
    winnerCount: number
    totalDeployed: string
    vaultedAmount: string
    totalWinnings: string
    motherlodeAmount: string
    endTime: number | string    // Unix timestamp or ISO date string
    settledAt?: number | string // Unix timestamp or ISO date string
}

interface RoundsResponse {
    rounds: RoundFromAPI[]
    pagination: {
        page: number
        limit: number
        total: number
        pages: number
    }
}

const BnbIcon = () => (
    <img
        src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
        alt="BNB"
        style={{ width: 16, height: 16, objectFit: "contain" as const }}
    />
)

const ChevronLeft = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
    </svg>
)

const ChevronRight = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z" />
    </svg>
)

// Helper functions
const formatWei = (wei: string): number => {
    if (!wei) return 0
    return parseFloat(wei) / 1e18
}

const formatAddress = (addr: string): string => {
    if (!addr) return '—'
    return `${addr.slice(0, 6)}...${addr.slice(-4)}`
}

const getRelativeTime = (timestamp: number | string): string => {
    // Handle ISO date string or Unix timestamp (seconds or milliseconds)
    let timeMs: number
    if (typeof timestamp === 'string') {
        timeMs = new Date(timestamp).getTime()
    } else if (timestamp > 1e12) {
        // Already in milliseconds
        timeMs = timestamp
    } else {
        // Unix seconds
        timeMs = timestamp * 1000
    }

    const seconds = Math.floor((Date.now() - timeMs) / 1000)
    if (seconds < 0) return 'just now'
    if (seconds < 60) return `${seconds} sec ago`
    if (seconds < 3600) return `${Math.floor(seconds / 60)} min ago`
    if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`
    return `${Math.floor(seconds / 86400)} days ago`
}

const transformRound = (r: RoundFromAPI): Round => ({
    round: r.roundId,
    block: r.winningBlock,
    winner: r.isSplit ? "Split" : formatAddress(r.beanWinner || ''),
    winners: r.winnerCount || 0,
    deployed: formatWei(r.totalDeployed),
    vaulted: formatWei(r.vaultedAmount),
    winnings: formatWei(r.totalWinnings),
    goldenBean: r.motherlodeAmount && parseFloat(r.motherlodeAmount) > 0
        ? formatWei(r.motherlodeAmount)
        : null,
    time: getRelativeTime(r.settledAt || r.endTime)
})

export default function MiningTable() {
    const [activeTab, setActiveTab] = useState<"rounds" | "goldenbeans">("rounds")
    const [currentPage, setCurrentPage] = useState(0)
    const [rounds, setRounds] = useState<Round[]>([])
    const [totalPages, setTotalPages] = useState(1)
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)
    const [mounted, setMounted] = useState(false)
    const rowsPerPage = 12

    // Prevent hydration mismatch by only rendering after mount
    useEffect(() => {
        setMounted(true)
    }, [])

    useEffect(() => {
        if (!mounted) return

        const fetchRounds = async () => {
            setLoading(true)
            setError(null)
            try {
                const beanpotParam = activeTab === "goldenbeans" ? "&beanpot=true" : ""
                const response = await apiFetch<RoundsResponse>(
                    `/api/rounds?page=${currentPage + 1}&limit=${rowsPerPage}&settled=true${beanpotParam}`
                )
                setRounds(response.rounds.map(transformRound))
                setTotalPages(response.pagination.pages)
            } catch (err) {
                console.error('Failed to fetch rounds:', err)
                setError('Failed to load rounds')
            } finally {
                setLoading(false)
            }
        }
        fetchRounds()
    }, [currentPage, activeTab, mounted])

    const handlePrevPage = () => {
        if (currentPage > 0) {
            setCurrentPage(currentPage - 1)
        }
    }

    const handleNextPage = () => {
        if (currentPage < totalPages - 1) {
            setCurrentPage(currentPage + 1)
        }
    }

    const handleTabChange = (tab: "rounds" | "goldenbeans") => {
        setActiveTab(tab)
        setCurrentPage(0)
    }

    // Return null until mounted to prevent hydration mismatch
    if (!mounted) {
        return null
    }

    if (loading && rounds.length === 0) {
        return <div style={styles.container}>Loading...</div>
    }

    if (error && rounds.length === 0) {
        return <div style={styles.container}>{error}</div>
    }

    return (
        <div style={styles.container}>
            <h2 style={styles.title}>Mining</h2>

            <div style={styles.tabs}>
                <button
                    style={{
                        ...styles.tab,
                        ...(activeTab === "rounds" ? styles.tabActive : {}),
                    }}
                    onClick={() => handleTabChange("rounds")}
                >
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66.19-.34.05-.08.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21z" />
                    </svg>
                    Rounds
                </button>
                <button
                    style={{
                        ...styles.tab,
                        ...(activeTab === "goldenbeans" ? styles.tabActive : {}),
                    }}
                    onClick={() => handleTabChange("goldenbeans")}
                >
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2L9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2z" />
                    </svg>
                    Beanpot
                </button>
            </div>

            <p style={styles.description}>
                {activeTab === "rounds"
                    ? "Recent mining rounds and winners."
                    : "Recent mining rounds where the Beanpot was hit."}
            </p>

            <div style={styles.tableWrapper}>
                <table style={styles.table}>
                    <thead>
                        <tr>
                            <th style={styles.th}>Round</th>
                            <th style={styles.th}>Block</th>
                            <th style={styles.th}>BEAN Winner</th>
                            <th style={styles.thCenter}>Winners</th>
                            <th style={styles.thRight}>Deployed</th>
                            <th style={styles.thRight}>Vaulted</th>
                            <th style={styles.thRight}>Winnings</th>
                            <th style={styles.thRight}>Beanpot</th>
                            <th style={styles.thRight}>Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        {rounds.map((round, index) => (
                            <tr key={round.round || index} style={styles.tr}>
                                <td style={styles.td}>#{round.round.toLocaleString()}</td>
                                <td style={styles.td}>#{round.block}</td>
                                <td style={styles.td}>
                                    {round.winner === "Split" ? (
                                        <span style={styles.splitBadge}>Split</span>
                                    ) : (
                                        <span>{round.winner}</span>
                                    )}
                                </td>
                                <td style={styles.tdCenter}>{round.winners}</td>
                                <td style={styles.tdRight}>
                                    <span style={styles.valueWithIcon}>
                                        <BnbIcon />
                                        {round.deployed.toFixed(4)}
                                    </span>
                                </td>
                                <td style={styles.tdRight}>
                                    <span style={styles.valueWithIcon}>
                                        <BnbIcon />
                                        {round.vaulted.toFixed(4)}
                                    </span>
                                </td>
                                <td style={styles.tdRight}>
                                    <span style={styles.valueWithIcon}>
                                        <BnbIcon />
                                        {round.winnings.toFixed(4)}
                                    </span>
                                </td>
                                <td style={styles.tdRight}>
                                    {round.goldenBean ? (
                                        <span style={styles.valueWithIcon}>
                                            <BeanLogo size={16} />
                                            {round.goldenBean.toFixed(2)}
                                        </span>
                                    ) : (
                                        <span style={styles.dash}>–</span>
                                    )}
                                </td>
                                <td style={styles.tdRight}>{round.time}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            <div style={styles.pagination}>
                <button
                    style={{
                        ...styles.pageBtn,
                        ...(currentPage === 0 ? styles.pageBtnDisabled : {}),
                    }}
                    onClick={handlePrevPage}
                    disabled={currentPage === 0}
                >
                    <ChevronLeft />
                </button>
                <button
                    style={{
                        ...styles.pageBtn,
                        ...(currentPage >= totalPages - 1 ? styles.pageBtnDisabled : {}),
                    }}
                    onClick={handleNextPage}
                    disabled={currentPage >= totalPages - 1}
                >
                    <ChevronRight />
                </button>
            </div>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        marginBottom: "48px",
    },
    title: {
        fontSize: "24px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "20px",
    },
    tabs: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "8px",
        marginBottom: "16px",
    },
    tab: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "8px",
        background: "transparent",
        border: "none",
        borderRadius: "8px",
        padding: "12px 24px",
        fontSize: "14px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    tabActive: {
        background: "#222",
        color: "#fff",
    },
    description: {
        fontSize: "14px",
        color: "#666",
        margin: 0,
        marginBottom: "24px",
    },
    tableWrapper: {
        overflowX: "auto",
    },
    table: {
        width: "100%",
        borderCollapse: "collapse",
    },
    th: {
        textAlign: "left" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
    },
    thCenter: {
        textAlign: "center" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
    },
    thRight: {
        textAlign: "right" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
    },
    tr: {
        borderBottom: "1px solid #111",
    },
    td: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        textAlign: "left" as const,
    },
    tdCenter: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        textAlign: "center" as const,
    },
    tdRight: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        textAlign: "right" as const,
    },
    splitBadge: {
        display: "inline-block",
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "4px 10px",
        fontSize: "12px",
        color: "#888",
    },
    valueWithIcon: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: "6px",
    },
    dash: {
        color: "#444",
    },
    pagination: {
        display: "flex",
        justifyContent: "flex-end",
        gap: "8px",
        marginTop: "16px",
    },
    pageBtn: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        width: "36px",
        height: "36px",
        background: "transparent",
        border: "1px solid #333",
        borderRadius: "8px",
        color: "#888",
        cursor: "pointer",
        transition: "all 0.15s",
    },
    pageBtnDisabled: {
        opacity: 0.3,
        cursor: "not-allowed",
    },
}

=== ./components/MobileControls.tsx ===
'use client'

import React, { useState, useEffect, useRef } from "react"
import { useConnectModal } from '@rainbow-me/rainbowkit'
import { MIN_DEPLOY_PER_BLOCK, EXECUTOR_FEE_BPS } from '@/lib/contracts'
import { apiFetch } from '@/lib/api'
import { useSSE } from '@/lib/SSEContext'
import { parseEther } from 'viem'

interface AutoMinerState {
    active: boolean
    strategyId: number
    numBlocks: number
    amountPerBlockFormatted: string
    numRounds: number
    roundsExecuted: number
    depositAmountFormatted: string
    costPerRoundFormatted: string
    roundsRemaining: number
    totalRefundableFormatted: string
}

interface MobileControlsProps {
    userBalance?: number
    isConnected?: boolean
    userAddress?: string
    onDeploy?: (amount: number, blockIds: number[]) => void
    onAutoActivate?: (strategyId: number, numRounds: number, numBlocks: number, depositAmount: bigint) => void
    onAutoStop?: () => void
}

const BNB_LOGO_URL = "https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"

export default function MobileControls({
    userBalance = 0,
    isConnected = false,
    userAddress,
    onDeploy,
    onAutoActivate,
    onAutoStop,
}: MobileControlsProps) {
    const { openConnectModal } = useConnectModal()
    const [mode, setMode] = useState<"manual" | "auto">("manual")
    const [perBlock, setPerBlock] = useState("0")
    const [selectedBlockCount, setSelectedBlockCount] = useState(0)
    const [selectedBlockIds, setSelectedBlockIds] = useState<number[]>([])

    // Auto mode state
    const [autoBlocks, setAutoBlocks] = useState(1)
    const [autoRounds, setAutoRounds] = useState(1)
    const [blockSelection, setBlockSelection] = useState<"all" | "random">("all")

    // AutoMiner state from backend
    const [autoMinerState, setAutoMinerState] = useState<AutoMinerState | null>(null)
    const autoMinerActive = autoMinerState?.active === true

    // Round data driven by MiningGrid events
    const [timer, setTimer] = useState(0)
    const [currentRound, setCurrentRound] = useState("")
    const [phase, setPhase] = useState<"counting" | "eliminating" | "winner">("counting")
    const [userDeployed, setUserDeployed] = useState(0)
    const endTimeRef = useRef(0)

    // Fetch AutoMiner state from backend
    useEffect(() => {
        if (!userAddress) {
            setAutoMinerState(null)
            return
        }

        const fetchAutoState = () => {
            apiFetch<{
                config: {
                    strategyId: number
                    numBlocks: number
                    amountPerBlockFormatted: string
                    active: boolean
                    numRounds: number
                    roundsExecuted: number
                    depositAmountFormatted: string
                }
                costPerRoundFormatted: string
                roundsRemaining: number
                totalRefundableFormatted: string
            }>(`/api/automine/${userAddress}`)
                .then((data) => {
                    setAutoMinerState({
                        active: data.config.active,
                        strategyId: data.config.strategyId,
                        numBlocks: data.config.numBlocks,
                        amountPerBlockFormatted: data.config.amountPerBlockFormatted,
                        numRounds: data.config.numRounds,
                        roundsExecuted: data.config.roundsExecuted,
                        depositAmountFormatted: data.config.depositAmountFormatted,
                        costPerRoundFormatted: data.costPerRoundFormatted,
                        roundsRemaining: data.roundsRemaining,
                        totalRefundableFormatted: data.totalRefundableFormatted,
                    })
                    if (data.config.active) {
                        setMode("auto")
                    }
                })
                .catch(() => {})
        }

        fetchAutoState()

        const handleActivated = () => setTimeout(fetchAutoState, 2000)
        const handleStopped = () => setTimeout(fetchAutoState, 2000)
        window.addEventListener("autoMinerActivated", handleActivated)
        window.addEventListener("autoMinerStopped", handleStopped)
        return () => {
            window.removeEventListener("autoMinerActivated", handleActivated)
            window.removeEventListener("autoMinerStopped", handleStopped)
        }
    }, [userAddress])

    // Subscribe to user SSE for real-time AutoMiner updates via centralized SSE context
    const { subscribeUser } = useSSE()

    useEffect(() => {
        const fetchAutoState = () => {
            if (!userAddress) return
            apiFetch<{
                config: {
                    strategyId: number
                    numBlocks: number
                    amountPerBlockFormatted: string
                    active: boolean
                    numRounds: number
                    roundsExecuted: number
                    depositAmountFormatted: string
                }
                costPerRoundFormatted: string
                roundsRemaining: number
                totalRefundableFormatted: string
            }>(`/api/automine/${userAddress}`)
                .then((data) => {
                    setAutoMinerState({
                        active: data.config.active,
                        strategyId: data.config.strategyId,
                        numBlocks: data.config.numBlocks,
                        amountPerBlockFormatted: data.config.amountPerBlockFormatted,
                        numRounds: data.config.numRounds,
                        roundsExecuted: data.config.roundsExecuted,
                        depositAmountFormatted: data.config.depositAmountFormatted,
                        costPerRoundFormatted: data.costPerRoundFormatted,
                        roundsRemaining: data.roundsRemaining,
                        totalRefundableFormatted: data.totalRefundableFormatted,
                    })
                    // If deactivated, switch back to allow manual mode
                    if (!data.config.active) {
                        setMode("manual")
                    }
                })
                .catch(() => {})
        }

        const unsub1 = subscribeUser('autoMineExecuted', fetchAutoState)
        const unsub2 = subscribeUser('configDeactivated', fetchAutoState)
        const unsub3 = subscribeUser('stopped', fetchAutoState)

        return () => {
            unsub1()
            unsub2()
            unsub3()
        }
    }, [subscribeUser, userAddress])

    useEffect(() => {
        const handleBlocksChanged = (event: CustomEvent) => {
            setSelectedBlockCount(event.detail.count)
            setSelectedBlockIds(event.detail.blocks || [])
        }
        window.addEventListener("blocksChanged" as any, handleBlocksChanged)
        return () => window.removeEventListener("blocksChanged" as any, handleBlocksChanged)
    }, [])

    // Listen for round data from MiningGrid
    useEffect(() => {
        const handleRoundData = (event: CustomEvent) => {
            const d = event.detail
            if (d.roundId) setCurrentRound(d.roundId)
            if (d.endTime) endTimeRef.current = typeof d.endTime === 'number' ? d.endTime : 0
            if (d.userDeployedFormatted !== undefined) setUserDeployed(parseFloat(d.userDeployedFormatted) || 0)
            setPhase("counting")
        }

        const handleRoundDeployed = (event: CustomEvent) => {
            const d = event.detail
            if (d.user && userAddress && d.user.toLowerCase() === userAddress.toLowerCase() && d.userDeployedFormatted) {
                setUserDeployed(parseFloat(d.userDeployedFormatted) || 0)
            }
        }

        const handleRoundSettled = () => {
            setPhase("eliminating")
            setTimeout(() => setPhase("winner"), 5200)
        }

        window.addEventListener("roundData" as any, handleRoundData)
        window.addEventListener("roundDeployed" as any, handleRoundDeployed)
        window.addEventListener("roundSettled" as any, handleRoundSettled)
        return () => {
            window.removeEventListener("roundData" as any, handleRoundData)
            window.removeEventListener("roundDeployed" as any, handleRoundDeployed)
            window.removeEventListener("roundSettled" as any, handleRoundSettled)
        }
    }, [userAddress])

    // Countdown timer from real endTime
    useEffect(() => {
        const tick = () => {
            if (endTimeRef.current > 0) {
                const remaining = Math.max(0, Math.floor(endTimeRef.current - Date.now() / 1000))
                setTimer(remaining)
            }
        }
        tick()
        const interval = setInterval(tick, 1000)
        return () => clearInterval(interval)
    }, [])

    const handleQuickAmount = (value: number) => {
        const current = parseFloat(perBlock) || 0
        setPerBlock((current + value).toFixed(5))
    }

    const handleAllClick = () => {
        if (mode === "manual") {
            const newSelectAll = selectedBlockCount !== 25
            window.dispatchEvent(new CustomEvent("selectAllBlocks", { detail: { selectAll: newSelectAll } }))
        } else {
            if (blockSelection === "all") {
                setBlockSelection("random")
                window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: true, strategy: "random" } }))
            } else {
                setBlockSelection("all")
                setAutoBlocks(25)
                window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: true, strategy: "all" } }))
            }
        }
    }

    // Manual mode calculations
    const perBlockAmount = parseFloat(perBlock) || 0
    const manualTotal = perBlockAmount * selectedBlockCount
    const hasDeployed = userDeployed > 0
    const exceedsBalance = manualTotal > userBalance
    const canDeploy = perBlockAmount >= MIN_DEPLOY_PER_BLOCK && selectedBlockCount > 0 && !exceedsBalance && timer > 0 && phase === "counting" && !hasDeployed

    // Auto mode calculations
    const autoNumBlocks = blockSelection === "all" ? 25 : autoBlocks
    const autoTotalBlocks = autoNumBlocks * autoRounds
    // Invert the fee formula to get required deposit from desired per-block
    const autoTotalDeposit = (perBlockAmount * autoTotalBlocks * (10000 + EXECUTOR_FEE_BPS)) / 10000
    const autoPerRound = autoRounds > 0 ? autoTotalDeposit / autoRounds : 0
    const exceedsBalanceAuto = autoTotalDeposit > userBalance
    const canActivate = perBlockAmount >= MIN_DEPLOY_PER_BLOCK && autoRounds >= 1 && !exceedsBalanceAuto

    const handleAutoActivateClick = () => {
        if (!canActivate) return
        const strategyId = blockSelection === "all" ? 1 : 0
        const depositAmount = parseEther(autoTotalDeposit.toFixed(18))
        onAutoActivate?.(strategyId, autoRounds, autoNumBlocks, depositAmount)
    }

    return (
        <>
            <div style={styles.container}>
                {/* Mode Toggle — hidden when AutoMiner active */}
                {!autoMinerActive && (
                    <div style={styles.modeToggle}>
                        <button
                            style={{...styles.modeBtn, ...(mode === "manual" ? styles.modeBtnActive : {})}}
                            onClick={() => {
                                setMode("manual")
                                window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: false, strategy: null } }))
                            }}
                        >
                            Manual
                        </button>
                        <button
                            style={{...styles.modeBtn, ...(mode === "auto" ? styles.modeBtnActive : {})}}
                            onClick={() => {
                                setMode("auto")
                                window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: true, strategy: blockSelection } }))
                            }}
                        >
                            Auto
                        </button>
                    </div>
                )}

                {/* ===== MANUAL MODE ===== */}
                {mode === "manual" && !autoMinerActive && (
                    <>
                        <div style={styles.balanceRow}>
                            <div style={styles.balanceLeft}>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="#666">
                                    <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z" />
                                </svg>
                                <span style={styles.balanceAmount}>{userBalance.toFixed(5)} BNB</span>
                            </div>
                            <div style={styles.quickAmounts}>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(1)}>+1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.1)}>+0.1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.01)}>+0.01</button>
                            </div>
                        </div>

                        <div style={styles.inputRow}>
                            <div style={styles.inputLeft}>
                                <img src={BNB_LOGO_URL} alt="BNB" style={{ width: 18, height: 18, objectFit: "contain" }} />
                                <span style={styles.inputLabel}>BNB</span>
                            </div>
                            <input
                                type="text"
                                style={styles.amountInput}
                                value={perBlock}
                                onChange={(e) => setPerBlock(e.target.value)}
                                onFocus={() => { if (perBlock === "0") setPerBlock("") }}
                                onBlur={() => { if (perBlock === "") setPerBlock("0") }}
                            />
                        </div>

                        <div style={styles.row}>
                            <span style={styles.rowLabel}>Blocks</span>
                            <div style={styles.rowRight}>
                                <button
                                    style={{...styles.allBtn, ...(selectedBlockCount === 25 ? styles.allBtnActive : {})}}
                                    onClick={handleAllClick}
                                >
                                    All
                                </button>
                                <span style={styles.blockCount}>
                                    {selectedBlockCount === 25 ? "x25" : "Random"}
                                </span>
                            </div>
                        </div>

                        <div style={styles.totalRow}>
                            <span style={styles.rowLabel}>Total</span>
                            <span style={styles.totalValue}>{manualTotal.toFixed(5)} BNB</span>
                        </div>

                        {isConnected ? (
                            <button
                                style={{...styles.deployBtn, ...(canDeploy ? styles.deployBtnActive : styles.deployBtnDisabled)}}
                                onClick={() => onDeploy?.(manualTotal, selectedBlockIds)}
                                disabled={!canDeploy}
                            >
                                {hasDeployed ? "✓ Deployed" : phase === "counting" ? "Deploy" : phase === "eliminating" ? "Settling..." : "Winner!"}
                            </button>
                        ) : (
                            <button style={styles.connectBtn} onClick={openConnectModal}>
                                Connect Wallet
                            </button>
                        )}
                    </>
                )}

                {/* ===== AUTO MODE — CONFIGURE VIEW ===== */}
                {mode === "auto" && !autoMinerActive && (
                    <>
                        <div style={styles.balanceRow}>
                            <div style={styles.balanceLeft}>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="#666">
                                    <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z" />
                                </svg>
                                <span style={styles.balanceAmount}>{userBalance.toFixed(5)} BNB</span>
                            </div>
                            <div style={styles.quickAmounts}>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(1)}>+1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.1)}>+0.1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.01)}>+0.01</button>
                            </div>
                        </div>

                        <div style={styles.inputRow}>
                            <div style={styles.inputLeft}>
                                <img src={BNB_LOGO_URL} alt="BNB" style={{ width: 18, height: 18, objectFit: "contain" }} />
                                <span style={styles.inputLabel}>BNB</span>
                            </div>
                            <input
                                type="text"
                                style={styles.amountInput}
                                value={perBlock}
                                onChange={(e) => setPerBlock(e.target.value)}
                                onFocus={() => { if (perBlock === "0") setPerBlock("") }}
                                onBlur={() => { if (perBlock === "") setPerBlock("0") }}
                            />
                        </div>

                        <div style={styles.row}>
                            <span style={styles.rowLabel}>Strategy</span>
                            <div style={styles.rowRight}>
                                <button
                                    style={{...styles.allBtn, ...(blockSelection === "all" ? styles.allBtnActive : {})}}
                                    onClick={handleAllClick}
                                >
                                    All
                                </button>
                                <span style={{ ...styles.blockCount, minWidth: "55px", textAlign: "right" }}>
                                    {blockSelection === "all" ? "x25" : "Random"}
                                </span>
                            </div>
                        </div>

                        <div style={{
                            ...styles.autoRow,
                            visibility: blockSelection === "random" ? "visible" : "hidden",
                            pointerEvents: blockSelection === "random" ? "auto" : "none",
                        }}>
                            <div style={styles.autoRowLeft}>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="#888">
                                    <circle cx="7" cy="7" r="2.5" />
                                    <circle cx="17" cy="7" r="2.5" />
                                    <circle cx="7" cy="17" r="2.5" />
                                    <circle cx="17" cy="17" r="2.5" />
                                </svg>
                                <span style={styles.autoRowLabel}>Blocks</span>
                            </div>
                            <input
                                type="number"
                                min="1"
                                max="25"
                                style={styles.autoInput}
                                value={autoBlocks === 0 ? "" : autoBlocks}
                                onChange={(e) => setAutoBlocks(Math.max(0, Math.min(25, parseInt(e.target.value) || 0)))}
                                onFocus={() => setAutoBlocks(0)}
                                onBlur={() => { if (autoBlocks === 0) setAutoBlocks(1) }}
                            />
                        </div>

                        <div style={styles.autoRow}>
                            <div style={styles.autoRowLeft}>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#888" strokeWidth="2">
                                    <line x1="4" y1="6" x2="20" y2="6" />
                                    <line x1="4" y1="12" x2="20" y2="12" />
                                    <line x1="4" y1="18" x2="20" y2="18" />
                                </svg>
                                <span style={styles.autoRowLabel}>Rounds</span>
                            </div>
                            <input
                                type="number"
                                min="1"
                                max="100"
                                style={styles.autoInput}
                                value={autoRounds === 0 ? "" : autoRounds}
                                onChange={(e) => setAutoRounds(Math.max(0, Math.min(100, parseInt(e.target.value) || 0)))}
                                onFocus={() => setAutoRounds(0)}
                                onBlur={() => { if (autoRounds === 0) setAutoRounds(1) }}
                            />
                        </div>

                        <div style={styles.row}>
                            <span style={styles.rowLabel}>Per round</span>
                            <span style={styles.totalValue}>{autoPerRound.toFixed(5)} BNB</span>
                        </div>

                        <div style={styles.totalRow}>
                            <span style={styles.rowLabel}>Total deposit</span>
                            <span style={styles.totalValue}>{autoTotalDeposit.toFixed(5)} BNB</span>
                        </div>

                        {isConnected ? (
                            <button
                                style={{...styles.deployBtn, ...(canActivate ? styles.deployBtnActive : styles.deployBtnDisabled)}}
                                onClick={handleAutoActivateClick}
                                disabled={!canActivate}
                            >
                                Activate AutoMiner
                            </button>
                        ) : (
                            <button style={styles.connectBtn} onClick={openConnectModal}>
                                Connect Wallet
                            </button>
                        )}
                    </>
                )}

                {/* ===== AUTO MODE — ACTIVE VIEW ===== */}
                {autoMinerActive && autoMinerState && (
                    <>
                        <div style={styles.activeHeader}>
                            <span style={styles.activeDot} />
                            <span style={styles.activeTitle}>AutoMiner Active</span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Balance</span>
                            <span style={styles.totalValue}>{parseFloat(autoMinerState.totalRefundableFormatted).toFixed(5)} BNB</span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Strategy</span>
                            <span style={styles.totalValue}>
                                {autoMinerState.strategyId === 1 ? "All" : "Random"} x{autoMinerState.numBlocks}
                            </span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Per round</span>
                            <span style={styles.totalValue}>{parseFloat(autoMinerState.costPerRoundFormatted).toFixed(5)} BNB</span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Rounds</span>
                            <span style={styles.totalValue}>
                                {autoMinerState.roundsExecuted} / {autoMinerState.numRounds}
                            </span>
                        </div>

                        <div style={{...styles.totalRow, borderTop: "1px solid #222"}}>
                            <span style={styles.rowLabel}>Per block</span>
                            <span style={styles.totalValue}>{parseFloat(autoMinerState.amountPerBlockFormatted).toFixed(5)} BNB</span>
                        </div>

                        <button
                            style={styles.stopBtn}
                            onClick={() => onAutoStop?.()}
                        >
                            Stop AutoMiner
                        </button>
                        <div style={styles.stopHint}>Cancel and refund remaining BNB</div>
                    </>
                )}
            </div>
        </>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        display: "flex",
        flexDirection: "column",
        gap: "10px",
        fontFamily: "'Inter', -apple-system, sans-serif",
        background: "#111",
        border: "1px solid #222",
        borderRadius: "12px",
        padding: "14px",
    },
    modeToggle: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "6px",
        background: "#0a0a0a",
        borderRadius: "8px",
        padding: "4px",
    },
    modeBtn: {
        background: "transparent",
        border: "none",
        borderRadius: "6px",
        padding: "10px",
        fontSize: "14px",
        fontWeight: 600,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    modeBtnActive: {
        background: "#222",
        color: "#fff",
    },
    balanceRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
    },
    balanceLeft: {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        fontSize: "13px",
    },
    balanceAmount: {
        color: "#fff",
        fontWeight: 600,
    },
    quickAmounts: {
        display: "flex",
        gap: "6px",
    },
    quickBtn: {
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "5px 10px",
        fontSize: "11px",
        fontWeight: 600,
        color: "#888",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    inputRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        background: "#0a0a0a",
        border: "1px solid #222",
        borderRadius: "8px",
        padding: "10px 12px",
    },
    inputLeft: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
    },
    inputLabel: {
        color: "#fff",
        fontSize: "14px",
        fontWeight: 600,
    },
    amountInput: {
        background: "transparent",
        border: "none",
        fontSize: "22px",
        fontWeight: 700,
        color: "#fff",
        textAlign: "right" as const,
        width: "100px",
        fontFamily: "inherit",
        outline: "none",
    },
    row: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
    },
    rowLabel: {
        fontSize: "13px",
        color: "#666",
        fontWeight: 500,
    },
    rowRight: {
        display: "flex",
        alignItems: "center",
        gap: "10px",
    },
    allBtn: {
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "5px 14px",
        fontSize: "12px",
        fontWeight: 600,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    allBtnActive: {
        background: "#444",
        color: "#fff",
        borderColor: "#666",
    },
    blockCount: {
        fontSize: "14px",
        fontWeight: 700,
        color: "#fff",
    },
    totalRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        paddingTop: "8px",
        borderTop: "1px solid #222",
    },
    totalValue: {
        fontSize: "14px",
        fontWeight: 700,
        color: "#fff",
    },
    autoRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "2px 0",
    },
    autoRowLeft: {
        display: "flex",
        alignItems: "center",
        gap: "10px",
    },
    autoRowLabel: {
        fontSize: "14px",
        color: "#fff",
        fontWeight: 600,
    },
    autoInput: {
        background: "transparent",
        border: "none",
        fontSize: "20px",
        fontWeight: 700,
        color: "#666",
        textAlign: "right" as const,
        width: "50px",
        fontFamily: "inherit",
        outline: "none",
    },
    deployBtn: {
        width: "100%",
        background: "#222",
        border: "none",
        borderRadius: "8px",
        padding: "12px",
        fontSize: "14px",
        fontWeight: 600,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    deployBtnActive: {
        background: "#F0B90B",
        color: "#000",
        cursor: "pointer",
    },
    deployBtnDisabled: {
        background: "#1a1a1a",
        color: "#444",
        cursor: "not-allowed",
    },
    connectBtn: {
        width: "100%",
        background: "#F0B90B",
        border: "none",
        borderRadius: "8px",
        padding: "12px",
        fontSize: "14px",
        fontWeight: 700,
        color: "#000",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    // Active AutoMiner styles
    activeHeader: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        padding: "4px 0",
    },
    activeDot: {
        width: "8px",
        height: "8px",
        borderRadius: "50%",
        background: "#4ade80",
    },
    activeTitle: {
        fontSize: "14px",
        fontWeight: 700,
        color: "#fff",
    },
    activeRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "4px 0",
    },
    stopBtn: {
        width: "100%",
        background: "#2a1a1a",
        border: "1px solid #442222",
        borderRadius: "8px",
        padding: "12px",
        fontSize: "14px",
        fontWeight: 600,
        color: "#f87171",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    stopHint: {
        fontSize: "11px",
        color: "#666",
        textAlign: "center",
        marginTop: "-4px",
    },
}

=== ./components/MobileMiners.tsx ===
'use client'

import React, { useState, useEffect } from "react"

interface Miner {
    address: string
    beansAmount: number
    bnbAmount: number
}

const mockMiners: Miner[] = [
    { address: "0x8Q4M...KJdZ", beansAmount: 0.1291, bnbAmount: 1.418094471 },
    { address: "0x6qJ6...6ZcE", beansAmount: 0.1076, bnbAmount: 1.181745392 },
    { address: "0x2NG3...LtBY", beansAmount: 0.0886, bnbAmount: 0.973758203 },
    { address: "0x9Upy...zqsu", beansAmount: 0.086, bnbAmount: 0.945396314 },
    { address: "0xGHxi...496n", beansAmount: 0.086, bnbAmount: 0.945396314 },
    { address: "0x86tD...4TPE", beansAmount: 0.0658, bnbAmount: 0.723431346 },
    { address: "0x4odE...P47z", beansAmount: 0.0538, bnbAmount: 0.590872696 },
    { address: "0xDiE1...d23v", beansAmount: 0.0516, bnbAmount: 0.567237788 },
]

export default function MobileMiners() {
    const [isExpanded, setIsExpanded] = useState(false)
    const [currentRound, setCurrentRound] = useState(122168)
    const [showMiners, setShowMiners] = useState(false)

    useEffect(() => {
        const handlePhaseChange = (event: CustomEvent) => {
            const { phase, round } = event.detail
            if (phase === "miners") {
                setCurrentRound(round)
                setShowMiners(true)
                setIsExpanded(true)
            }
        }

        window.addEventListener("phaseChange" as any, handlePhaseChange)
        return () => window.removeEventListener("phaseChange" as any, handlePhaseChange)
    }, [])

    if (!showMiners) return null

    return (
        <div style={styles.container}>
            <button 
                style={styles.header}
                onClick={() => setIsExpanded(!isExpanded)}
            >
                <div style={styles.headerLeft}>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="#F0B90B">
                        <path d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm14 0c0 1.3-.84 2.4-2 2.82V7h2v1z" />
                    </svg>
                    <span style={styles.title}>Miners</span>
                    <span style={styles.roundLabel}>Round #{currentRound - 1}</span>
                </div>
                <svg 
                    width="20" 
                    height="20" 
                    viewBox="0 0 24 24" 
                    fill="#666"
                    style={{ transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}
                >
                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
                </svg>
            </button>

            {isExpanded && (
                <div style={styles.minersList}>
                    {mockMiners.map((miner, index) => (
                        <div key={index} style={styles.minerRow}>
                            <span style={styles.minerAddress}>{miner.address}</span>
                            <div style={styles.minerAmounts}>
                                <span style={styles.beansAmount}>🫘 {miner.beansAmount.toFixed(4)}</span>
                                <span style={styles.bnbAmount}>+ ⛓️ {miner.bnbAmount.toFixed(4)}</span>
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        background: '#111',
        border: '1px solid #222',
        borderRadius: '12px',
        overflow: 'hidden',
        fontFamily: "'Inter', -apple-system, sans-serif",
    },
    header: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '14px 16px',
        background: 'transparent',
        border: 'none',
        width: '100%',
        cursor: 'pointer',
    },
    headerLeft: {
        display: 'flex',
        alignItems: 'center',
        gap: '10px',
    },
    title: {
        fontSize: '15px',
        fontWeight: 600,
        color: '#fff',
    },
    roundLabel: {
        fontSize: '12px',
        color: '#666',
    },
    minersList: {
        borderTop: '1px solid #222',
        maxHeight: '300px',
        overflowY: 'auto',
    },
    minerRow: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: '12px 16px',
        borderBottom: '1px solid #1a1a1a',
    },
    minerAddress: {
        fontSize: '13px',
        color: '#fff',
        fontFamily: 'monospace',
    },
    minerAmounts: {
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
    },
    beansAmount: {
        fontSize: '12px',
        color: '#F0B90B',
    },
    bnbAmount: {
        fontSize: '12px',
        color: '#666',
    },
}

=== ./components/MobileStatsBar.tsx ===
'use client'

import React, { useState, useEffect, useRef } from "react"

// Move icons OUTSIDE component to prevent re-creation on each render
const BeanIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="#F0B90B">
        <ellipse cx="12" cy="10" rx="7" ry="5" />
        <ellipse cx="12" cy="14" rx="7" ry="5" />
    </svg>
)

const BNB_LOGO_URL = "https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"

interface MobileStatsBarProps {
    userAddress?: string
}

export default function MobileStatsBar({ userAddress }: MobileStatsBarProps) {
    const [timer, setTimer] = useState(0)
    const [motherlodePool, setMotherlodePool] = useState(0)
    const [totalDeployed, setTotalDeployed] = useState(0)
    const [userDeployed, setUserDeployed] = useState(0)
    const endTimeRef = useRef(0)

    // Listen for round data from MiningGrid
    useEffect(() => {
        const handleRoundData = (event: CustomEvent) => {
            const d = event.detail
            if (d.endTime) endTimeRef.current = typeof d.endTime === 'number' ? d.endTime : 0
            if (d.motherlodePoolFormatted) setMotherlodePool(parseFloat(d.motherlodePoolFormatted) || 0)
            if (d.totalDeployedFormatted !== undefined) setTotalDeployed(parseFloat(d.totalDeployedFormatted) || 0)
            if (d.userDeployedFormatted !== undefined) setUserDeployed(parseFloat(d.userDeployedFormatted) || 0)
        }

        const handleRoundDeployed = (event: CustomEvent) => {
            const d = event.detail
            if (d.totalDeployedFormatted) setTotalDeployed(parseFloat(d.totalDeployedFormatted) || 0)
            // Update user deployed if this deployment is from the connected user
            if (d.user && userAddress && d.user.toLowerCase() === userAddress.toLowerCase() && d.userDeployedFormatted) {
                setUserDeployed(parseFloat(d.userDeployedFormatted) || 0)
            }
        }

        window.addEventListener("roundData" as any, handleRoundData)
        window.addEventListener("roundDeployed" as any, handleRoundDeployed)
        return () => {
            window.removeEventListener("roundData" as any, handleRoundData)
            window.removeEventListener("roundDeployed" as any, handleRoundDeployed)
        }
    }, [userAddress])

    // Countdown timer from real endTime
    useEffect(() => {
        const tick = () => {
            if (endTimeRef.current > 0) {
                const remaining = Math.max(0, Math.floor(endTimeRef.current - Date.now() / 1000))
                setTimer(remaining)
            }
        }
        tick()
        const interval = setInterval(tick, 1000)
        return () => clearInterval(interval)
    }, [])

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60)
        const secs = seconds % 60
        return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`
    }

    return (
        <div style={styles.container}>
            <div style={styles.row}>
                <div style={styles.stat}>
                    <div style={styles.valueRow}>
                        <BeanIcon />
                        <span style={styles.value}>
                            {motherlodePool > 0 ? motherlodePool.toFixed(1) : '—'}
                        </span>
                    </div>
                    <span style={styles.label}>Beanpot</span>
                </div>
                <div style={styles.stat}>
                    <div style={styles.valueRow}>
                        <span style={styles.value}>{formatTime(timer)}</span>
                    </div>
                    <span style={styles.label}>Time remaining</span>
                </div>
            </div>
            <div style={styles.row}>
                <div style={styles.stat}>
                    <div style={styles.valueRow}>
                        <img src={BNB_LOGO_URL} alt="BNB" style={styles.bnbLogo} />
                        <span style={styles.value}>
                            {totalDeployed > 0 ? totalDeployed.toFixed(4) : '—'}
                        </span>
                    </div>
                    <span style={styles.label}>Total deployed</span>
                </div>
                <div style={styles.stat}>
                    <div style={styles.valueRow}>
                        <img src={BNB_LOGO_URL} alt="BNB" style={styles.bnbLogo} />
                        <span style={styles.value}>{userDeployed > 0 ? userDeployed.toFixed(4) : '—'}</span>
                    </div>
                    <span style={styles.label}>You deployed</span>
                </div>
            </div>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        display: 'flex',
        flexDirection: 'column',
        gap: '10px',
        fontFamily: "'Inter', -apple-system, sans-serif",
    },
    row: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '10px',
    },
    stat: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '6px',
        background: '#111',
        border: '1px solid #222',
        borderRadius: '12px',
        padding: '16px 10px',
    },
    valueRow: {
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
    },
    value: {
        fontSize: '22px',
        fontWeight: 700,
        color: '#fff',
    },
    label: {
        fontSize: '13px',
        color: '#666',
        fontWeight: 500,
    },
    bnbLogo: {
        width: 20,
        height: 20,
        objectFit: 'contain' as const,
    },
}

=== ./components/RevenueTable.tsx ===
'use client'

import React, { useState, useEffect } from "react"
import BeanLogo from "./BeanLogo"
import { apiFetch } from '../lib/api'

// Display interface (for table rendering)
interface BuybackEntry {
    time: string
    spent: number
    burned: number
    yieldGenerated: number
}

// API response interfaces
interface BuybackFromAPI {
    bnbSpent: string
    bnbSpentFormatted: string
    beanReceived: string
    beanReceivedFormatted: string
    beanBurned: string
    beanBurnedFormatted: string
    beanToStakers: string
    beanToStakersFormatted: string
    txHash: string
    blockNumber: number
    timestamp: string
}

interface BuybacksResponse {
    buybacks: BuybackFromAPI[]
    pagination: {
        page: number
        limit: number
        total: number
        pages: number
    }
}

// Helper functions
const getRelativeTime = (timestamp: string): string => {
    const timeMs = new Date(timestamp).getTime()
    const seconds = Math.floor((Date.now() - timeMs) / 1000)
    if (seconds < 0) return 'just now'
    if (seconds < 60) return `${seconds} sec ago`
    if (seconds < 3600) return `${Math.floor(seconds / 60)} min ago`
    if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`
    return `${Math.floor(seconds / 86400)} days ago`
}

const transformBuyback = (b: BuybackFromAPI): BuybackEntry => ({
    time: getRelativeTime(b.timestamp),
    spent: parseFloat(b.bnbSpentFormatted),
    burned: parseFloat(b.beanBurnedFormatted),
    yieldGenerated: parseFloat(b.beanToStakersFormatted)
})

// Pagination icons
const ChevronLeft = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
    </svg>
)

const ChevronRight = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z" />
    </svg>
)

// SVG Icons
const BnbIcon = () => (
    <img
        src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
        alt="BNB"
        style={{ width: 16, height: 16, objectFit: "contain" as const }}
    />
)

export default function RevenueTable() {
    const [buybacks, setBuybacks] = useState<BuybackEntry[]>([])
    const [currentPage, setCurrentPage] = useState(0)
    const [totalPages, setTotalPages] = useState(1)
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null)
    const [isMobile, setIsMobile] = useState(false)
    const [mounted, setMounted] = useState(false)
    const rowsPerPage = 12

    useEffect(() => {
        setMounted(true)
    }, [])

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768)
        checkMobile()
        window.addEventListener('resize', checkMobile)
        return () => window.removeEventListener('resize', checkMobile)
    }, [])

    useEffect(() => {
        if (!mounted) return

        const fetchBuybacks = async () => {
            setLoading(true)
            setError(null)
            try {
                const response = await apiFetch<BuybacksResponse>(
                    `/api/treasury/buybacks?page=${currentPage + 1}&limit=${rowsPerPage}`
                )
                setBuybacks(response.buybacks.map(transformBuyback))
                setTotalPages(response.pagination.pages)
            } catch (err) {
                console.error('Failed to fetch buybacks:', err)
                setError('Failed to load buybacks')
            } finally {
                setLoading(false)
            }
        }
        fetchBuybacks()
    }, [currentPage, mounted])

    const handlePrevPage = () => {
        if (currentPage > 0) {
            setCurrentPage(currentPage - 1)
        }
    }

    const handleNextPage = () => {
        if (currentPage < totalPages - 1) {
            setCurrentPage(currentPage + 1)
        }
    }

    // Return null until mounted to prevent hydration mismatch
    if (!mounted) {
        return null
    }

    if (loading && buybacks.length === 0) {
        return <div style={styles.container}>Loading...</div>
    }

    if (error && buybacks.length === 0) {
        return <div style={styles.container}>{error}</div>
    }

    return (
        <div style={isMobile ? styles.containerMobile : styles.container}>
            <h2 style={isMobile ? styles.titleMobile : styles.title}>Revenue</h2>

            {/* Description */}
            <p style={isMobile ? styles.descriptionMobile : styles.description}>
                Transactions where protocol revenue was used to buy back BEANS from the spot market.
            </p>

            {/* Table */}
            <div style={styles.tableWrapper}>
                <table style={styles.table}>
                    <thead>
                        <tr>
                            <th style={styles.th}>Time</th>
                            <th style={styles.thRight}>Spent</th>
                            <th style={styles.thRight}>Burned</th>
                            <th style={styles.thRight}>Yield Generated</th>
                        </tr>
                    </thead>
                    <tbody>
                        {buybacks.map((entry, index) => (
                            <tr key={index} style={styles.tr}>
                                <td style={styles.td}>{entry.time}</td>
                                <td style={styles.tdRight}>
                                    <span style={styles.valueWithIcon}>
                                        <BnbIcon />
                                        {entry.spent.toFixed(4)}
                                    </span>
                                </td>
                                <td style={styles.tdRight}>
                                    <span style={styles.valueWithIcon}>
                                        <BeanLogo size={16} />
                                        {entry.burned.toFixed(4)}
                                    </span>
                                </td>
                                <td style={styles.tdRight}>
                                    <span style={styles.valueWithIcon}>
                                        <BeanLogo size={16} />
                                        {entry.yieldGenerated.toFixed(4)}
                                    </span>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>

            {/* Pagination */}
            <div style={styles.pagination}>
                <button
                    style={{
                        ...styles.pageBtn,
                        ...(currentPage === 0 ? styles.pageBtnDisabled : {}),
                    }}
                    onClick={handlePrevPage}
                    disabled={currentPage === 0}
                >
                    <ChevronLeft />
                </button>
                <button
                    style={{
                        ...styles.pageBtn,
                        ...(currentPage >= totalPages - 1 ? styles.pageBtnDisabled : {}),
                    }}
                    onClick={handleNextPage}
                    disabled={currentPage >= totalPages - 1}
                >
                    <ChevronRight />
                </button>
            </div>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        marginBottom: "48px",
    },
    containerMobile: {
        marginBottom: "32px",
    },
    title: {
        fontSize: "24px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "20px",
    },
    titleMobile: {
        fontSize: "18px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "12px",
    },
    description: {
        fontSize: "14px",
        color: "#666",
        margin: 0,
        marginBottom: "24px",
    },
    descriptionMobile: {
        fontSize: "12px",
        color: "#666",
        margin: 0,
        marginBottom: "16px",
    },
    tableWrapper: {
        overflowX: "auto",
    },
    table: {
        width: "100%",
        borderCollapse: "collapse",
        minWidth: "400px",
    },
    th: {
        textAlign: "left" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
        whiteSpace: "nowrap" as const,
    },
    thRight: {
        textAlign: "right" as const,
        padding: "12px 16px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        borderBottom: "1px solid #1a1a1a",
        whiteSpace: "nowrap" as const,
    },
    tr: {
        borderBottom: "1px solid #111",
    },
    td: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        whiteSpace: "nowrap" as const,
    },
    tdRight: {
        padding: "14px 16px",
        fontSize: "14px",
        color: "#fff",
        textAlign: "right" as const,
        whiteSpace: "nowrap" as const,
    },
    valueWithIcon: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: "6px",
    },
    pagination: {
        display: "flex",
        justifyContent: "flex-end",
        gap: "8px",
        marginTop: "16px",
    },
    pageBtn: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        width: "36px",
        height: "36px",
        background: "transparent",
        border: "1px solid #333",
        borderRadius: "8px",
        color: "#888",
        cursor: "pointer",
        transition: "all 0.15s",
    },
    pageBtnDisabled: {
        opacity: 0.3,
        cursor: "not-allowed",
    },
}

=== ./components/SidebarControls.tsx ===
'use client'

import React, { useState, useEffect, useRef } from "react"
import { useConnectModal } from '@rainbow-me/rainbowkit'
import BeanLogo from './BeanLogo'
import { apiFetch } from '@/lib/api'
import { useSSE } from '@/lib/SSEContext'
import { MIN_DEPLOY_PER_BLOCK, EXECUTOR_FEE_BPS } from '@/lib/contracts'
import { parseEther } from 'viem'

const BnbLogo = ({ size = 18 }: { size?: number }) => (
    <img
        src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public"
        alt="BNB"
        style={{ width: size, height: size, objectFit: "contain" as const }}
    />
)

const WalletIcon = () => (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="#666">
        <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z" />
    </svg>
)

const BlocksIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="#888">
        <circle cx="7" cy="7" r="2.5" />
        <circle cx="17" cy="7" r="2.5" />
        <circle cx="7" cy="17" r="2.5" />
        <circle cx="17" cy="17" r="2.5" />
    </svg>
)

const RoundsIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#888" strokeWidth="2">
        <line x1="4" y1="6" x2="20" y2="6" />
        <line x1="4" y1="12" x2="20" y2="12" />
        <line x1="4" y1="18" x2="20" y2="18" />
    </svg>
)

interface AutoMinerState {
    active: boolean
    strategyId: number
    numBlocks: number
    amountPerBlockFormatted: string
    numRounds: number
    roundsExecuted: number
    depositAmountFormatted: string
    costPerRoundFormatted: string
    roundsRemaining: number
    totalRefundableFormatted: string
}

interface SidebarControlsProps {
    userBalance?: number
    isConnected?: boolean
    userAddress?: string
    onDeploy?: (amount: number, blockIds: number[]) => void
    onAutoActivate?: (strategyId: number, numRounds: number, numBlocks: number, depositAmount: bigint) => void
    onAutoStop?: () => void
}

export default function SidebarControls({
    userBalance = 0,
    isConnected = false,
    userAddress,
    onDeploy,
    onAutoActivate,
    onAutoStop,
}: SidebarControlsProps) {
    const { openConnectModal } = useConnectModal()
    const [mode, setMode] = useState<"manual" | "auto">("manual")
    const [hoveredMode, setHoveredMode] = useState<string | null>(null)
    const [perBlock, setPerBlock] = useState("0")

    const [selectedBlockCount, setSelectedBlockCount] = useState(0)
    const [selectedBlockIds, setSelectedBlockIds] = useState<number[]>([])

    const [autoBlocks, setAutoBlocks] = useState(1)
    const [autoRounds, setAutoRounds] = useState(1)
    const [blockSelection, setBlockSelection] = useState<"all" | "random">("all")

    // AutoMiner state from backend
    const [autoMinerState, setAutoMinerState] = useState<AutoMinerState | null>(null)
    const autoMinerActive = autoMinerState?.active === true

    // Round data driven by MiningGrid events
    const [timer, setTimer] = useState(0)
    const [currentRound, setCurrentRound] = useState("")
    const [phase, setPhase] = useState<"counting" | "eliminating" | "winner">("counting")
    const endTimeRef = useRef(0)

    // Stats
    const [motherlodePool, setMotherlodePool] = useState(0)
    const [totalDeployed, setTotalDeployed] = useState(0)
    const [userDeployed, setUserDeployed] = useState(0)

    const [isHoveringTimer, setIsHoveringTimer] = useState(false)
    const [isHoveringBeanpot, setIsHoveringBeanpot] = useState(false)
    const [isHoveringTotalDeployed, setIsHoveringTotalDeployed] = useState(false)
    const [isHoveringYouDeployed, setIsHoveringYouDeployed] = useState(false)

    const [bnbPrice, setBnbPrice] = useState<number>(0)
    const [beansPrice, setBeansPrice] = useState<number>(0)

    // Fetch AutoMiner state from backend
    useEffect(() => {
        if (!userAddress) {
            setAutoMinerState(null)
            return
        }

        const fetchAutoState = () => {
            apiFetch<{
                config: {
                    strategyId: number
                    numBlocks: number
                    amountPerBlockFormatted: string
                    active: boolean
                    numRounds: number
                    roundsExecuted: number
                    depositAmountFormatted: string
                }
                costPerRoundFormatted: string
                roundsRemaining: number
                totalRefundableFormatted: string
            }>(`/api/automine/${userAddress}`)
                .then((data) => {
                    setAutoMinerState({
                        active: data.config.active,
                        strategyId: data.config.strategyId,
                        numBlocks: data.config.numBlocks,
                        amountPerBlockFormatted: data.config.amountPerBlockFormatted,
                        numRounds: data.config.numRounds,
                        roundsExecuted: data.config.roundsExecuted,
                        depositAmountFormatted: data.config.depositAmountFormatted,
                        costPerRoundFormatted: data.costPerRoundFormatted,
                        roundsRemaining: data.roundsRemaining,
                        totalRefundableFormatted: data.totalRefundableFormatted,
                    })
                    // Force auto mode if active
                    if (data.config.active) {
                        setMode("auto")
                    }
                })
                .catch(() => {})
        }

        fetchAutoState()

        const handleActivated = () => setTimeout(fetchAutoState, 2000)
        const handleStopped = () => setTimeout(fetchAutoState, 2000)
        window.addEventListener("autoMinerActivated", handleActivated)
        window.addEventListener("autoMinerStopped", handleStopped)
        return () => {
            window.removeEventListener("autoMinerActivated", handleActivated)
            window.removeEventListener("autoMinerStopped", handleStopped)
        }
    }, [userAddress])

    // Subscribe to user SSE for real-time AutoMiner updates via centralized SSE context
    const { subscribeUser } = useSSE()

    useEffect(() => {
        const fetchAutoState = () => {
            if (!userAddress) return
            apiFetch<{
                config: {
                    strategyId: number
                    numBlocks: number
                    amountPerBlockFormatted: string
                    active: boolean
                    numRounds: number
                    roundsExecuted: number
                    depositAmountFormatted: string
                }
                costPerRoundFormatted: string
                roundsRemaining: number
                totalRefundableFormatted: string
            }>(`/api/automine/${userAddress}`)
                .then((data) => {
                    setAutoMinerState({
                        active: data.config.active,
                        strategyId: data.config.strategyId,
                        numBlocks: data.config.numBlocks,
                        amountPerBlockFormatted: data.config.amountPerBlockFormatted,
                        numRounds: data.config.numRounds,
                        roundsExecuted: data.config.roundsExecuted,
                        depositAmountFormatted: data.config.depositAmountFormatted,
                        costPerRoundFormatted: data.costPerRoundFormatted,
                        roundsRemaining: data.roundsRemaining,
                        totalRefundableFormatted: data.totalRefundableFormatted,
                    })
                    // If deactivated, switch back to allow manual mode
                    if (!data.config.active) {
                        setMode("manual")
                    }
                })
                .catch(() => {})
        }

        const unsub1 = subscribeUser('autoMineExecuted', fetchAutoState)
        const unsub2 = subscribeUser('configDeactivated', fetchAutoState)
        const unsub3 = subscribeUser('stopped', fetchAutoState)

        return () => {
            unsub1()
            unsub2()
            unsub3()
        }
    }, [subscribeUser, userAddress])

    // Listen for block selection changes
    useEffect(() => {
        const handleBlocksChanged = (event: CustomEvent) => {
            const { blocks, count } = event.detail
            setSelectedBlockCount(count)
            setSelectedBlockIds(blocks || [])
        }

        window.addEventListener("blocksChanged" as any, handleBlocksChanged)
        return () => window.removeEventListener("blocksChanged" as any, handleBlocksChanged)
    }, [])

    // Fetch prices from backend
    useEffect(() => {
        const fetchPrices = () => {
            apiFetch<{ prices: { bean: { usd: string }, bnb: { usd: string } } }>('/api/stats')
                .then((data) => {
                    setBnbPrice(parseFloat(data.prices.bnb.usd) || 0)
                    setBeansPrice(parseFloat(data.prices.bean.usd) || 0)
                })
                .catch((err) => console.error('Failed to fetch prices:', err))
        }

        fetchPrices()
        const interval = setInterval(fetchPrices, 30000)
        return () => clearInterval(interval)
    }, [])

    // Listen for round data from MiningGrid
    useEffect(() => {
        const handleRoundData = (event: CustomEvent) => {
            const d = event.detail
            if (d.roundId) setCurrentRound(d.roundId)
            if (d.endTime) endTimeRef.current = typeof d.endTime === 'number' ? d.endTime : 0
            if (d.motherlodePoolFormatted) setMotherlodePool(parseFloat(d.motherlodePoolFormatted) || 0)
            if (d.totalDeployedFormatted !== undefined) setTotalDeployed(parseFloat(d.totalDeployedFormatted) || 0)
            if (d.userDeployedFormatted !== undefined) setUserDeployed(parseFloat(d.userDeployedFormatted) || 0)
            // New round data means we're back to counting
            setPhase("counting")
        }

        const handleRoundDeployed = (event: CustomEvent) => {
            const d = event.detail
            if (d.totalDeployedFormatted) setTotalDeployed(parseFloat(d.totalDeployedFormatted) || 0)
            // Update user deployed if this deployment is from the connected user
            if (d.user && userAddress && d.user.toLowerCase() === userAddress.toLowerCase() && d.userDeployedFormatted) {
                setUserDeployed(parseFloat(d.userDeployedFormatted) || 0)
            }
        }

        const handleRoundSettled = () => {
            setPhase("eliminating")
            setTimeout(() => setPhase("winner"), 5200)
        }

        window.addEventListener("roundData" as any, handleRoundData)
        window.addEventListener("roundDeployed" as any, handleRoundDeployed)
        window.addEventListener("roundSettled" as any, handleRoundSettled)
        return () => {
            window.removeEventListener("roundData" as any, handleRoundData)
            window.removeEventListener("roundDeployed" as any, handleRoundDeployed)
            window.removeEventListener("roundSettled" as any, handleRoundSettled)
        }
    }, [userAddress])

    // Countdown timer from real endTime
    useEffect(() => {
        const tick = () => {
            if (endTimeRef.current > 0) {
                const remaining = Math.max(0, Math.floor(endTimeRef.current - Date.now() / 1000))
                setTimer(remaining)
            }
        }
        tick()
        const interval = setInterval(tick, 1000)
        return () => clearInterval(interval)
    }, [])

    const formatTime = (seconds: number) => {
        const mins = Math.floor(seconds / 60)
        const secs = seconds % 60
        return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`
    }

    const handleQuickAmount = (value: number) => {
        const current = parseFloat(perBlock) || 0
        setPerBlock((current + value).toFixed(5))
    }

    const handleAllClick = () => {
        if (blockSelection === "all") {
            setBlockSelection("random")
            window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: true, strategy: "random" } }))
        } else {
            setBlockSelection("all")
            setAutoBlocks(25)
            window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: true, strategy: "all" } }))
        }
    }

    // Manual mode calculations
    const perBlockAmount = parseFloat(perBlock) || 0
    const manualTotal = perBlockAmount * selectedBlockCount
    const hasDeployed = userDeployed > 0
    const exceedsBalance = manualTotal > userBalance
    const canDeploy = perBlockAmount >= MIN_DEPLOY_PER_BLOCK && selectedBlockCount > 0 && !exceedsBalance && timer > 0 && phase === "counting" && !hasDeployed

    // Auto mode calculations
    const autoNumBlocks = blockSelection === "all" ? 25 : autoBlocks
    const autoTotalBlocks = autoNumBlocks * autoRounds
    // Invert the fee formula to get required deposit from desired per-block
    // Contract formula: effectivePerBlock = (deposit * 10000) / (totalBlocks * (10000 + feeBps))
    // Inverting: deposit = effectivePerBlock * totalBlocks * (10000 + feeBps) / 10000
    const autoTotalDeposit = (perBlockAmount * autoTotalBlocks * (10000 + EXECUTOR_FEE_BPS)) / 10000
    const autoPerRound = autoRounds > 0 ? autoTotalDeposit / autoRounds : 0
    const exceedsBalanceAuto = autoTotalDeposit > userBalance
    const canActivate = perBlockAmount >= MIN_DEPLOY_PER_BLOCK && autoRounds >= 1 && !exceedsBalanceAuto

    const handleAutoActivateClick = () => {
        if (!canActivate) return
        const strategyId = blockSelection === "all" ? 1 : 0
        const depositAmount = parseEther(autoTotalDeposit.toFixed(18))
        onAutoActivate?.(strategyId, autoRounds, autoNumBlocks, depositAmount)
    }

    return (
        <div style={styles.container}>
            <div style={styles.statsGrid}>
                <div
                    style={{ ...styles.statBox, ...styles.beanpotBox }}
                    onMouseEnter={() => setIsHoveringBeanpot(true)}
                    onMouseLeave={() => setIsHoveringBeanpot(false)}
                >
                    <div style={styles.statValue}>
                        <BeanLogo size={20} />
                        <span style={styles.beanpotValue}>
                            {motherlodePool > 0 ? motherlodePool.toFixed(1) : '—'}
                        </span>
                    </div>
                    <div style={styles.statLabel}>
                        {isHoveringBeanpot && motherlodePool > 0
                            ? `≈$${(motherlodePool * beansPrice).toFixed(2)}`
                            : "Beanpot"}
                    </div>
                </div>

                <div
                    style={styles.statBox}
                    onMouseEnter={() => setIsHoveringTimer(true)}
                    onMouseLeave={() => setIsHoveringTimer(false)}
                >
                    <div style={styles.statValue}>
                        <span style={styles.timerValue}>{formatTime(timer)}</span>
                    </div>
                    <div style={styles.statLabel}>
                        {isHoveringTimer && currentRound ? `Round #${currentRound}` : "Time remaining"}
                    </div>
                </div>

                <div
                    style={styles.statBox}
                    onMouseEnter={() => setIsHoveringTotalDeployed(true)}
                    onMouseLeave={() => setIsHoveringTotalDeployed(false)}
                >
                    <div style={styles.statValue}>
                        <BnbLogo size={20} />
                        <span style={styles.statValueText}>
                            {totalDeployed > 0 ? totalDeployed.toFixed(5) : '—'}
                        </span>
                    </div>
                    <div style={styles.statLabel}>
                        {isHoveringTotalDeployed && totalDeployed > 0
                            ? `≈$${(totalDeployed * bnbPrice).toFixed(2)}`
                            : "Total deployed"}
                    </div>
                </div>

                <div
                    style={styles.statBox}
                    onMouseEnter={() => setIsHoveringYouDeployed(true)}
                    onMouseLeave={() => setIsHoveringYouDeployed(false)}
                >
                    <div style={styles.statValue}>
                        <BnbLogo size={20} />
                        <span style={styles.statValueText}>{userDeployed > 0 ? userDeployed.toFixed(5) : '—'}</span>
                    </div>
                    <div style={styles.statLabel}>
                        {isHoveringYouDeployed && userDeployed > 0
                            ? `≈$${(userDeployed * bnbPrice).toFixed(2)}`
                            : "You deployed"}
                    </div>
                </div>
            </div>

            <div style={styles.controlsCard}>
                {/* Mode toggle — hidden when AutoMiner is active */}
                {!autoMinerActive && (
                    <div style={styles.modeToggle}>
                        <button
                            style={{
                                ...styles.modeBtn,
                                ...(mode === "manual" ? styles.modeBtnActive : {}),
                                ...(hoveredMode === "manual" && mode !== "manual" ? styles.modeBtnHover : {}),
                            }}
                            onClick={() => {
                                setMode("manual")
                                window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: false, strategy: null } }))
                            }}
                            onMouseEnter={() => setHoveredMode("manual")}
                            onMouseLeave={() => setHoveredMode(null)}
                        >
                            Manual
                        </button>
                        <button
                            style={{
                                ...styles.modeBtn,
                                ...(mode === "auto" ? styles.modeBtnActive : {}),
                                ...(hoveredMode === "auto" && mode !== "auto" ? styles.modeBtnHover : {}),
                            }}
                            onClick={() => {
                                setMode("auto")
                                window.dispatchEvent(new CustomEvent("autoMinerMode", { detail: { enabled: true, strategy: blockSelection } }))
                            }}
                            onMouseEnter={() => setHoveredMode("auto")}
                            onMouseLeave={() => setHoveredMode(null)}
                        >
                            Auto
                        </button>
                    </div>
                )}

                {/* ===== MANUAL MODE ===== */}
                {mode === "manual" && !autoMinerActive && (
                    <>
                        <div style={styles.balanceRow}>
                            <div style={styles.balanceLeft}>
                                <WalletIcon />
                                <span style={styles.balanceAmount}>{userBalance.toFixed(5)} BNB</span>
                            </div>
                            <div style={styles.quickAmounts}>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(1)}>+1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.1)}>+0.1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.01)}>+0.01</button>
                            </div>
                        </div>

                        <div style={styles.inputRow}>
                            <div style={styles.inputLeft}>
                                <BnbLogo size={20} />
                                <span style={styles.inputLabel}>BNB</span>
                            </div>
                            <input
                                type="text"
                                style={{ ...styles.amountInput, color: "#fff" }}
                                value={perBlock}
                                onChange={(e) => setPerBlock(e.target.value)}
                                onFocus={() => { if (perBlock === "0") setPerBlock("") }}
                                onBlur={() => { if (perBlock === "") setPerBlock("0") }}
                            />
                        </div>

                        <div style={styles.row}>
                            <span style={styles.rowLabel}>Blocks</span>
                            <div style={styles.rowRight}>
                                <button
                                    style={{
                                        ...styles.allBtn,
                                        ...(selectedBlockCount === 25 ? styles.allBtnActive : {}),
                                    }}
                                    onClick={() => {
                                        window.dispatchEvent(
                                            new CustomEvent("selectAllBlocks", {
                                                detail: { selectAll: selectedBlockCount !== 25 },
                                            })
                                        )
                                    }}
                                >
                                    All
                                </button>
                                <span style={styles.blockCount}>
                                    {selectedBlockCount === 25 ? "x25" : "Random"}
                                </span>
                            </div>
                        </div>

                        <div style={styles.totalRow}>
                            <span style={styles.rowLabel}>Total</span>
                            <span style={styles.totalValue}>{manualTotal.toFixed(5)} BNB</span>
                        </div>

                        {isConnected ? (
                            <button
                                style={{
                                    ...styles.deployBtn,
                                    ...(canDeploy ? styles.deployBtnActive : styles.deployBtnDisabled),
                                }}
                                onClick={() => onDeploy?.(manualTotal, selectedBlockIds)}
                                disabled={!canDeploy}
                            >
                                {hasDeployed ? "✓ Deployed" : phase === "counting" ? "Deploy" : phase === "eliminating" ? "Settling..." : "Winner!"}
                            </button>
                        ) : (
                            <button style={styles.connectBtn} onClick={openConnectModal}>
                                Connect Wallet
                            </button>
                        )}
                    </>
                )}

                {/* ===== AUTO MODE — CONFIGURE VIEW ===== */}
                {mode === "auto" && !autoMinerActive && (
                    <>
                        <div style={styles.balanceRow}>
                            <div style={styles.balanceLeft}>
                                <WalletIcon />
                                <span style={styles.balanceAmount}>{userBalance.toFixed(5)} BNB</span>
                            </div>
                            <div style={styles.quickAmounts}>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(1)}>+1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.1)}>+0.1</button>
                                <button style={styles.quickBtn} onClick={() => handleQuickAmount(0.01)}>+0.01</button>
                            </div>
                        </div>

                        <div style={styles.inputRow}>
                            <div style={styles.inputLeft}>
                                <BnbLogo size={20} />
                                <span style={styles.inputLabel}>BNB</span>
                            </div>
                            <input
                                type="text"
                                style={{ ...styles.amountInput, color: "#fff" }}
                                value={perBlock}
                                onChange={(e) => setPerBlock(e.target.value)}
                                onFocus={() => { if (perBlock === "0") setPerBlock("") }}
                                onBlur={() => { if (perBlock === "") setPerBlock("0") }}
                            />
                        </div>

                        <div style={styles.row}>
                            <span style={styles.rowLabel}>Strategy</span>
                            <div style={styles.blockSelectionToggle}>
                                <button
                                    style={{
                                        ...styles.allBtn,
                                        ...(blockSelection === "all" ? styles.allBtnActive : {}),
                                    }}
                                    onClick={handleAllClick}
                                >
                                    All
                                </button>
                                <span style={{ ...styles.blockCount, minWidth: "55px", textAlign: "right" }}>
                                    {blockSelection === "all" ? "x25" : "Random"}
                                </span>
                            </div>
                        </div>

                        <div style={{
                            ...styles.autoRow,
                            visibility: blockSelection === "random" ? "visible" : "hidden",
                            pointerEvents: blockSelection === "random" ? "auto" : "none",
                        }}>
                            <div style={styles.autoRowLeft}>
                                <BlocksIcon />
                                <span style={styles.autoRowLabel}>Blocks</span>
                            </div>
                            <input
                                type="number"
                                min="1"
                                max="25"
                                style={styles.autoInput}
                                value={autoBlocks === 0 ? "" : autoBlocks}
                                onChange={(e) => setAutoBlocks(Math.max(0, Math.min(25, parseInt(e.target.value) || 0)))}
                                onFocus={() => setAutoBlocks(0)}
                                onBlur={() => { if (autoBlocks === 0) setAutoBlocks(1) }}
                            />
                        </div>

                        <div style={styles.autoRow}>
                            <div style={styles.autoRowLeft}>
                                <RoundsIcon />
                                <span style={styles.autoRowLabel}>Rounds</span>
                            </div>
                            <input
                                type="number"
                                min="1"
                                max="100"
                                style={styles.autoInput}
                                value={autoRounds === 0 ? "" : autoRounds}
                                onChange={(e) => setAutoRounds(Math.max(0, Math.min(100, parseInt(e.target.value) || 0)))}
                                onFocus={() => setAutoRounds(0)}
                                onBlur={() => { if (autoRounds === 0) setAutoRounds(1) }}
                            />
                        </div>

                        <div style={styles.row}>
                            <span style={styles.rowLabel}>Per round</span>
                            <span style={styles.totalValue}>{autoPerRound.toFixed(5)} BNB</span>
                        </div>

                        <div style={styles.totalRow}>
                            <span style={styles.rowLabel}>Total deposit</span>
                            <span style={styles.totalValue}>{autoTotalDeposit.toFixed(5)} BNB</span>
                        </div>

                        {isConnected ? (
                            <button
                                style={{
                                    ...styles.deployBtn,
                                    ...(canActivate ? styles.deployBtnActive : styles.deployBtnDisabled),
                                }}
                                onClick={handleAutoActivateClick}
                                disabled={!canActivate}
                            >
                                Activate AutoMiner
                            </button>
                        ) : (
                            <button style={styles.connectBtn} onClick={openConnectModal}>
                                Connect Wallet
                            </button>
                        )}
                    </>
                )}

                {/* ===== AUTO MODE — ACTIVE VIEW ===== */}
                {autoMinerActive && autoMinerState && (
                    <>
                        <div style={styles.activeHeader}>
                            <span style={styles.activeDot} />
                            <span style={styles.activeTitle}>AutoMiner Active</span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Balance</span>
                            <span style={styles.totalValue}>{parseFloat(autoMinerState.totalRefundableFormatted).toFixed(5)} BNB</span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Strategy</span>
                            <span style={styles.totalValue}>
                                {autoMinerState.strategyId === 1 ? "All" : "Random"} x{autoMinerState.numBlocks}
                            </span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Per round</span>
                            <span style={styles.totalValue}>{parseFloat(autoMinerState.costPerRoundFormatted).toFixed(5)} BNB</span>
                        </div>

                        <div style={styles.activeRow}>
                            <span style={styles.rowLabel}>Rounds</span>
                            <span style={styles.totalValue}>
                                {autoMinerState.roundsExecuted} / {autoMinerState.numRounds}
                            </span>
                        </div>

                        <div style={{ ...styles.totalRow, borderTop: "1px solid #222" }}>
                            <span style={styles.rowLabel}>Per block</span>
                            <span style={styles.totalValue}>{parseFloat(autoMinerState.amountPerBlockFormatted).toFixed(5)} BNB</span>
                        </div>

                        <button
                            style={styles.stopBtn}
                            onClick={() => onAutoStop?.()}
                        >
                            Stop AutoMiner
                        </button>
                        <div style={styles.stopHint}>Cancel and refund remaining BNB</div>
                    </>
                )}
            </div>
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        display: "flex",
        flexDirection: "column",
        gap: "16px",
        fontFamily: "'Inter', -apple-system, sans-serif",
        width: "100%",
    },
    statsGrid: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "12px",
    },
    statBox: {
        background: "#111",
        border: "1px solid #222",
        borderRadius: "12px",
        padding: "14px 12px",
        textAlign: "center",
    },
    beanpotBox: {
        border: "1px solid #2a2a2a",
    },
    statValue: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        fontSize: "20px",
        fontWeight: 700,
        color: "#fff",
        marginBottom: "4px",
    },
    statValueText: {
        fontWeight: 700,
    },
    beanpotValue: {
        color: "#fff",
        fontWeight: 700,
    },
    timerValue: {
        color: "#fff",
        fontWeight: 700,
    },
    statLabel: {
        fontSize: "13px",
        color: "#666",
        fontWeight: 500,
    },
    controlsCard: {
        background: "#111",
        border: "1px solid #222",
        borderRadius: "12px",
        padding: "16px",
        display: "flex",
        flexDirection: "column",
        gap: "12px",
    },
    modeToggle: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "8px",
        background: "#0a0a0a",
        borderRadius: "8px",
        padding: "4px",
    },
    modeBtn: {
        background: "transparent",
        border: "none",
        borderRadius: "6px",
        padding: "10px",
        fontSize: "14px",
        fontWeight: 600,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    modeBtnActive: {
        background: "#222",
        color: "#fff",
    },
    modeBtnHover: {
        background: "#1a1a1a",
        color: "#888",
    },
    balanceRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
    },
    balanceLeft: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        color: "#666",
        fontSize: "14px",
        fontWeight: 500,
    },
    balanceAmount: {
        color: "#fff",
        fontWeight: 600,
    },
    quickAmounts: {
        display: "flex",
        gap: "8px",
    },
    quickBtn: {
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "6px 12px",
        fontSize: "12px",
        fontWeight: 600,
        color: "#888",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    inputRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        background: "#0a0a0a",
        border: "1px solid #222",
        borderRadius: "8px",
        padding: "10px 14px",
    },
    inputLeft: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        color: "#fff",
        fontSize: "14px",
        fontWeight: 600,
    },
    inputLabel: {
        color: "#fff",
        fontWeight: 600,
    },
    amountInput: {
        background: "transparent",
        border: "none",
        fontSize: "24px",
        fontWeight: 700,
        textAlign: "right" as const,
        width: "100px",
        fontFamily: "inherit",
        outline: "none",
    },
    autoRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "4px 0",
    },
    autoRowLeft: {
        display: "flex",
        alignItems: "center",
        gap: "12px",
    },
    autoRowLabel: {
        fontSize: "15px",
        color: "#fff",
        fontWeight: 600,
    },
    autoInput: {
        background: "transparent",
        border: "none",
        fontSize: "24px",
        fontWeight: 700,
        color: "#666",
        textAlign: "right" as const,
        width: "60px",
        fontFamily: "inherit",
        outline: "none",
    },
    row: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "4px 0",
    },
    rowLabel: {
        fontSize: "14px",
        color: "#666",
        fontWeight: 500,
    },
    rowRight: {
        display: "flex",
        alignItems: "center",
        gap: "12px",
    },
    allBtn: {
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "6px 16px",
        fontSize: "13px",
        fontWeight: 600,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    allBtnActive: {
        background: "#444",
        color: "#fff",
        borderColor: "#666",
    },
    blockCount: {
        fontSize: "15px",
        fontWeight: 700,
        color: "#fff",
    },
    blockSelectionToggle: {
        display: "flex",
        alignItems: "center",
        gap: "12px",
    },
    totalRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "8px 0",
        borderTop: "1px solid #222",
    },
    totalValue: {
        fontSize: "15px",
        fontWeight: 700,
        color: "#fff",
    },
    deployBtn: {
        width: "100%",
        background: "#222",
        border: "none",
        borderRadius: "8px",
        padding: "14px",
        fontSize: "14px",
        fontWeight: 600,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    deployBtnActive: {
        background: "#F0B90B",
        color: "#000",
        cursor: "pointer",
    },
    deployBtnDisabled: {
        background: "#1a1a1a",
        color: "#444",
        cursor: "not-allowed",
    },
    connectBtn: {
        width: "100%",
        background: "#F0B90B",
        border: "none",
        borderRadius: "8px",
        padding: "14px",
        fontSize: "14px",
        fontWeight: 700,
        color: "#000",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    // Active AutoMiner styles
    activeHeader: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        padding: "4px 0",
    },
    activeDot: {
        width: "8px",
        height: "8px",
        borderRadius: "50%",
        background: "#4ade80",
    },
    activeTitle: {
        fontSize: "15px",
        fontWeight: 700,
        color: "#fff",
    },
    activeRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "6px 0",
    },
    stopBtn: {
        width: "100%",
        background: "#2a1a1a",
        border: "1px solid #442222",
        borderRadius: "8px",
        padding: "14px",
        fontSize: "14px",
        fontWeight: 600,
        color: "#f87171",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    stopHint: {
        fontSize: "12px",
        color: "#666",
        textAlign: "center",
        marginTop: "-4px",
    },
}

=== ./components/StakePage.tsx ===
'use client'

import React, { useState, useEffect } from "react"
import { useConnectModal } from '@rainbow-me/rainbowkit'
import BeanLogo from './BeanLogo'

interface StakePageProps {
    userBalance?: number
    userStaked?: number
    isConnected?: boolean
    isMobile?: boolean
    onDeposit?: (amount: number) => void
    onWithdraw?: (amount: number) => void
}

export default function StakePage({
    userBalance = 0,
    userStaked = 0,
    isConnected = false,
    isMobile = false,
    onDeposit,
    onWithdraw,
}: StakePageProps) {
    const { openConnectModal } = useConnectModal()
    const [activeTab, setActiveTab] = useState<"deposit" | "withdraw">("deposit")
    const [amount, setAmount] = useState("0")
    const [beansPrice, setBeansPrice] = useState<number>(0.0264)
    const [showCalculator, setShowCalculator] = useState(false)
    const [calcAmount, setCalcAmount] = useState("1000")

    const [totalDeposits] = useState(277606)
    const [apr] = useState(15.27)
    const [tvl] = useState(39213198)

    useEffect(() => {
        const fetchBeansPrice = async () => {
            try {
                const response = await fetch(
                    "https://api.dexscreener.com/latest/dex/pairs/bsc/0x7e58f160b5b77b8b24cd9900c09a3e730215ac47"
                )
                const data = await response.json()
                if (data.pair?.priceUsd) {
                    setBeansPrice(parseFloat(data.pair.priceUsd))
                }
            } catch (error) {
                console.error("Failed to fetch BEANS price:", error)
            }
        }

        fetchBeansPrice()
        const interval = setInterval(fetchBeansPrice, 30000)
        return () => clearInterval(interval)
    }, [])

    const handleHalf = () => {
        const balance = activeTab === "deposit" ? userBalance : userStaked
        setAmount((balance / 2).toFixed(4))
    }

    const handleAll = () => {
        const balance = activeTab === "deposit" ? userBalance : userStaked
        setAmount(balance.toFixed(4))
    }

    const handleAction = () => {
        const value = parseFloat(amount) || 0
        if (activeTab === "deposit") {
            onDeposit?.(value)
        } else {
            onWithdraw?.(value)
        }
    }

    const currentBalance = activeTab === "deposit" ? userBalance : userStaked

    const calcBeansAmount = parseFloat(calcAmount) || 0
    const dailyRate = apr / 365
    const weeklyRate = apr / 52
    const monthlyRate = apr / 12
    const dailyEarnings = (calcBeansAmount * dailyRate) / 100
    const weeklyEarnings = (calcBeansAmount * weeklyRate) / 100
    const monthlyEarnings = (calcBeansAmount * monthlyRate) / 100

    return (
        <div style={isMobile ? styles.containerMobile : styles.container}>
            <div style={isMobile ? styles.contentMobile : styles.content}>
                <div style={isMobile ? styles.headerMobile : styles.header}>
                    <h1 style={isMobile ? styles.titleMobile : styles.title}>Stake</h1>
                    <p style={isMobile ? styles.subtitleMobile : styles.subtitle}>
                        Earn a share of protocol revenue.
                    </p>
                </div>

                <div style={isMobile ? styles.cardMobile : styles.card}>
                    <div style={isMobile ? styles.tabsMobile : styles.tabs}>
                        <button
                            style={{
                                ...(isMobile ? styles.tabMobile : styles.tab),
                                ...(activeTab === "deposit" ? styles.tabActive : {}),
                            }}
                            onClick={() => setActiveTab("deposit")}
                        >
                            Deposit
                        </button>
                        <button
                            style={{
                                ...(isMobile ? styles.tabMobile : styles.tab),
                                ...(activeTab === "withdraw" ? styles.tabActive : {}),
                            }}
                            onClick={() => setActiveTab("withdraw")}
                        >
                            Withdraw
                        </button>
                    </div>

                    <div style={isMobile ? styles.balanceRowMobile : styles.balanceRow}>
                        <div style={styles.balanceLeft}>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="#666">
                                <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z" />
                            </svg>
                            <span style={isMobile ? styles.balanceTextMobile : styles.balanceText}>
                                {currentBalance.toFixed(4)} BEANS
                            </span>
                        </div>
                        <div style={styles.quickBtns}>
                            <button style={isMobile ? styles.quickBtnMobile : styles.quickBtn} onClick={handleHalf}>
                                HALF
                            </button>
                            <button style={isMobile ? styles.quickBtnMobile : styles.quickBtn} onClick={handleAll}>
                                ALL
                            </button>
                        </div>
                    </div>

                    <div style={isMobile ? styles.inputRowMobile : styles.inputRow}>
                        <div style={styles.inputLeft}>
                            <BeanLogo size={isMobile ? 20 : 24} />
                            <span style={isMobile ? styles.inputLabelMobile : styles.inputLabel}>BEANS</span>
                        </div>
                        <input
                            type="text"
                            style={isMobile ? styles.amountInputMobile : styles.amountInput}
                            value={amount}
                            onChange={(e) => setAmount(e.target.value)}
                            placeholder="0.0"
                        />
                    </div>

                    {isConnected ? (
                        <button
                            style={{
                                ...(isMobile ? styles.actionBtnMobile : styles.actionBtn),
                                ...(parseFloat(amount) <= 0 ? styles.actionBtnDisabled : styles.actionBtnEnabled),
                            }}
                            onClick={handleAction}
                            disabled={parseFloat(amount) <= 0}
                        >
                            {activeTab === "deposit" ? "Deposit" : "Withdraw"}
                        </button>
                    ) : (
                        <button 
                            style={{
                                ...(isMobile ? styles.actionBtnMobile : styles.actionBtn),
                                ...styles.actionBtnEnabled,
                            }} 
                            onClick={openConnectModal}
                        >
                            {activeTab === "deposit" ? "Deposit" : "Withdraw"}
                        </button>
                    )}
                </div>

                <div style={isMobile ? styles.summaryMobile : styles.summary}>
                    <h2 style={isMobile ? styles.summaryTitleMobile : styles.summaryTitle}>Summary</h2>

                    <div style={isMobile ? styles.summaryRowMobile : styles.summaryRow}>
                        <div style={styles.summaryLabel}>
                            <span style={isMobile ? { fontSize: '13px' } : {}}>Total deposits</span>
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="#666">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
                            </svg>
                        </div>
                        <div style={isMobile ? styles.summaryValueMobile : styles.summaryValue}>
                            <BeanLogo size={14} />
                            <span>{totalDeposits.toLocaleString()}</span>
                        </div>
                    </div>

                    <div style={isMobile ? styles.summaryRowMobile : styles.summaryRow}>
                        <div style={styles.summaryLabel}>
                            <span style={isMobile ? { fontSize: '13px' } : {}}>APR</span>
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="#666">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
                            </svg>
                        </div>
                        <span style={isMobile ? styles.summaryValueMobile : styles.summaryValue}>{apr}%</span>
                    </div>

                    <div style={isMobile ? styles.summaryRowMobile : styles.summaryRow}>
                        <div style={styles.summaryLabel}>
                            <span style={isMobile ? { fontSize: '13px' } : {}}>TVL</span>
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="#666">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
                            </svg>
                        </div>
                        <span style={isMobile ? styles.summaryValueMobile : styles.summaryValue}>
                            ${tvl.toLocaleString()}
                        </span>
                    </div>
                </div>

                <button
                    style={isMobile ? styles.calculatorBtnMobile : styles.calculatorBtn}
                    onClick={() => setShowCalculator(true)}
                >
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1V18z" />
                    </svg>
                    APR Calculator
                </button>
            </div>

            {showCalculator && (
                <>
                    <div style={styles.overlay} onClick={() => setShowCalculator(false)} />
                    <div style={isMobile ? styles.modalMobile : styles.modal}>
                        <div style={styles.modalHeader}>
                            <h3 style={isMobile ? styles.modalTitleMobile : styles.modalTitle}>APR Calculator</h3>
                            <button style={styles.closeBtn} onClick={() => setShowCalculator(false)}>✕</button>
                        </div>

                        <div style={styles.calcInputRow}>
                            <span style={styles.calcLabel}>BEANS to stake</span>
                            <div style={styles.calcInputWrapper}>
                                <BeanLogo size={18} />
                                <input
                                    type="text"
                                    style={styles.calcInput}
                                    value={calcAmount}
                                    onChange={(e) => setCalcAmount(e.target.value)}
                                    placeholder="1000"
                                />
                            </div>
                        </div>

                        <div style={styles.calcResults}>
                            <div style={styles.calcResultRow}>
                                <span style={styles.calcResultLabel}>Daily</span>
                                <div style={styles.calcResultValue}>
                                    <BeanLogo size={14} />
                                    <span>{dailyEarnings.toFixed(4)}</span>
                                    <span style={styles.calcUsd}>(${(dailyEarnings * beansPrice).toFixed(2)})</span>
                                </div>
                            </div>
                            <div style={styles.calcResultRow}>
                                <span style={styles.calcResultLabel}>Weekly</span>
                                <div style={styles.calcResultValue}>
                                    <BeanLogo size={14} />
                                    <span>{weeklyEarnings.toFixed(4)}</span>
                                    <span style={styles.calcUsd}>(${(weeklyEarnings * beansPrice).toFixed(2)})</span>
                                </div>
                            </div>
                            <div style={styles.calcResultRow}>
                                <span style={styles.calcResultLabel}>Monthly</span>
                                <div style={styles.calcResultValue}>
                                    <BeanLogo size={14} />
                                    <span>{monthlyEarnings.toFixed(4)}</span>
                                    <span style={styles.calcUsd}>(${(monthlyEarnings * beansPrice).toFixed(2)})</span>
                                </div>
                            </div>
                            <div style={styles.calcResultRow}>
                                <span style={styles.calcResultLabel}>Yearly</span>
                                <div style={styles.calcResultValue}>
                                    <BeanLogo size={14} />
                                    <span>{(monthlyEarnings * 12).toFixed(4)}</span>
                                    <span style={styles.calcUsd}>(${(monthlyEarnings * 12 * beansPrice).toFixed(2)})</span>
                                </div>
                            </div>
                        </div>

                        <p style={styles.calcNote}>Based on current APR of {apr}%. Actual returns may vary.</p>
                    </div>
                </>
            )}
        </div>
    )
}

const styles: { [key: string]: React.CSSProperties } = {
    container: {
        background: "#0a0a0a",
        fontFamily: "'Inter', -apple-system, sans-serif",
        display: "flex",
        justifyContent: "center",
        paddingTop: "30px",
    },
    containerMobile: {
        background: "#0a0a0a",
        fontFamily: "'Inter', -apple-system, sans-serif",
        padding: "0 16px",
    },
    content: {
        width: "100%",
        maxWidth: "580px",
        padding: "0 20px",
    },
    contentMobile: {
        width: "100%",
    },
    header: {
        marginBottom: "24px",
    },
    headerMobile: {
        marginBottom: "16px",
    },
    title: {
        fontSize: "36px",
        fontWeight: 700,
        color: "#fff",
        margin: 0,
        marginBottom: "8px",
    },
    titleMobile: {
        fontSize: "24px",
        fontWeight: 700,
        color: "#fff",
        margin: 0,
        marginBottom: "4px",
    },
    subtitle: {
        fontSize: "16px",
        color: "#666",
        margin: 0,
    },
    subtitleMobile: {
        fontSize: "13px",
        color: "#666",
        margin: 0,
    },
    card: {
        background: "#111",
        border: "1px solid #222",
        borderRadius: "16px",
        padding: "24px",
        marginBottom: "28px",
    },
    cardMobile: {
        background: "#111",
        border: "1px solid #222",
        borderRadius: "14px",
        padding: "16px",
        marginBottom: "20px",
    },
    tabs: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "8px",
        background: "#0a0a0a",
        borderRadius: "12px",
        padding: "8px",
        marginBottom: "24px",
    },
    tabsMobile: {
        display: "grid",
        gridTemplateColumns: "1fr 1fr",
        gap: "6px",
        background: "#0a0a0a",
        borderRadius: "10px",
        padding: "6px",
        marginBottom: "16px",
    },
    tab: {
        background: "transparent",
        border: "none",
        borderRadius: "8px",
        padding: "14px",
        fontSize: "14px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    tabMobile: {
        background: "transparent",
        border: "none",
        borderRadius: "8px",
        padding: "12px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
        transition: "all 0.15s",
    },
    tabActive: {
        background: "#222",
        color: "#fff",
    },
    balanceRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: "16px",
    },
    balanceRowMobile: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: "12px",
    },
    balanceLeft: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
    },
    balanceText: {
        fontSize: "14px",
        color: "#666",
    },
    balanceTextMobile: {
        fontSize: "12px",
        color: "#666",
    },
    quickBtns: {
        display: "flex",
        gap: "8px",
    },
    quickBtn: {
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "8px 16px",
        fontSize: "12px",
        fontWeight: 600,
        color: "#888",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    quickBtnMobile: {
        background: "#1a1a1a",
        border: "1px solid #333",
        borderRadius: "6px",
        padding: "6px 12px",
        fontSize: "11px",
        fontWeight: 600,
        color: "#888",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    inputRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        background: "#0a0a0a",
        border: "1px solid #222",
        borderRadius: "12px",
        padding: "16px 20px",
        marginBottom: "24px",
    },
    inputRowMobile: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        background: "#0a0a0a",
        border: "1px solid #222",
        borderRadius: "10px",
        padding: "14px 16px",
        marginBottom: "16px",
    },
    inputLeft: {
        display: "flex",
        alignItems: "center",
        gap: "10px",
    },
    inputLabel: {
        fontSize: "16px",
        fontWeight: 500,
        color: "#fff",
    },
    inputLabelMobile: {
        fontSize: "14px",
        fontWeight: 500,
        color: "#fff",
    },
    amountInput: {
        background: "transparent",
        border: "none",
        fontSize: "28px",
        fontWeight: 600,
        color: "#fff",
        textAlign: "right" as const,
        width: "150px",
        fontFamily: "inherit",
        outline: "none",
    },
    amountInputMobile: {
        background: "transparent",
        border: "none",
        fontSize: "24px",
        fontWeight: 600,
        color: "#fff",
        textAlign: "right" as const,
        width: "120px",
        fontFamily: "inherit",
        outline: "none",
    },
    actionBtn: {
        width: "100%",
        background: "#222",
        border: "none",
        borderRadius: "12px",
        padding: "18px",
        fontSize: "16px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    actionBtnMobile: {
        width: "100%",
        background: "#222",
        border: "none",
        borderRadius: "10px",
        padding: "14px",
        fontSize: "15px",
        fontWeight: 500,
        color: "#666",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    actionBtnEnabled: {
        background: "#F0B90B",
        color: "#000",
        fontWeight: 600,
    },
    actionBtnDisabled: {
        background: "#1a1a1a",
        color: "#444",
        cursor: "not-allowed",
    },
    summary: {
        marginBottom: "20px",
    },
    summaryMobile: {
        marginBottom: "16px",
    },
    summaryTitle: {
        fontSize: "24px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "16px",
    },
    summaryTitleMobile: {
        fontSize: "18px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
        marginBottom: "12px",
    },
    summaryRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "16px 0",
        borderBottom: "1px solid #1a1a1a",
    },
    summaryRowMobile: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "12px 0",
        borderBottom: "1px solid #1a1a1a",
    },
    summaryLabel: {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        fontSize: "15px",
        color: "#666",
    },
    summaryValue: {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        fontSize: "15px",
        fontWeight: 500,
        color: "#fff",
    },
    summaryValueMobile: {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        fontSize: "14px",
        fontWeight: 500,
        color: "#fff",
    },
    calculatorBtn: {
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "10px",
        background: "transparent",
        border: "1px solid #333",
        borderRadius: "12px",
        padding: "16px",
        fontSize: "14px",
        fontWeight: 500,
        color: "#888",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    calculatorBtnMobile: {
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "8px",
        background: "transparent",
        border: "1px solid #333",
        borderRadius: "10px",
        padding: "12px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#888",
        cursor: "pointer",
        fontFamily: "inherit",
    },
    overlay: {
        position: "fixed" as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: "rgba(0,0,0,0.7)",
        zIndex: 1000,
    },
    modal: {
        position: "fixed" as const,
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        background: "#111",
        border: "1px solid #222",
        borderRadius: "16px",
        padding: "24px",
        width: "90%",
        maxWidth: "420px",
        zIndex: 1001,
    },
    modalMobile: {
        position: "fixed" as const,
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        background: "#111",
        border: "1px solid #222",
        borderRadius: "14px",
        padding: "20px",
        width: "90%",
        maxWidth: "360px",
        zIndex: 1001,
    },
    modalHeader: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: "20px",
    },
    modalTitle: {
        fontSize: "20px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
    },
    modalTitleMobile: {
        fontSize: "18px",
        fontWeight: 600,
        color: "#fff",
        margin: 0,
    },
    closeBtn: {
        background: "transparent",
        border: "none",
        color: "#666",
        fontSize: "18px",
        cursor: "pointer",
        padding: "4px 8px",
    },
    calcInputRow: {
        marginBottom: "20px",
    },
    calcLabel: {
        display: "block",
        fontSize: "13px",
        color: "#666",
        marginBottom: "8px",
    },
    calcInputWrapper: {
        display: "flex",
        alignItems: "center",
        gap: "10px",
        background: "#0a0a0a",
        border: "1px solid #222",
        borderRadius: "10px",
        padding: "12px 14px",
    },
    calcInput: {
        flex: 1,
        background: "transparent",
        border: "none",
        fontSize: "16px",
        fontWeight: 500,
        color: "#fff",
        fontFamily: "inherit",
        outline: "none",
    },
    calcResults: {
        background: "#0a0a0a",
        borderRadius: "10px",
        padding: "12px",
        marginBottom: "12px",
    },
    calcResultRow: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "10px 0",
        borderBottom: "1px solid #1a1a1a",
    },
    calcResultLabel: {
        fontSize: "13px",
        color: "#666",
    },
    calcResultValue: {
        display: "flex",
        alignItems: "center",
        gap: "5px",
        fontSize: "13px",
        fontWeight: 500,
        color: "#fff",
    },
    calcUsd: {
        color: "#666",
        fontSize: "12px",
    },
    calcNote: {
        fontSize: "11px",
        color: "#555",
        textAlign: "center" as const,
        margin: 0,
    },
}

=== ./components/WalletButton.tsx ===
'use client'

import { ConnectButton } from '@rainbow-me/rainbowkit'
import { useState, useRef, useEffect } from 'react'
import { useBalance, useReadContract, useDisconnect } from 'wagmi'

const BEANS_ADDRESS = '0x000Ae314E2A2172a039B26378814C252734f556A'

const erc20Abi = [
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'decimals',
    outputs: [{ name: '', type: 'uint8' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const

export default function WalletButton() {
  const [isOpen, setIsOpen] = useState(false)
  const popupRef = useRef<HTMLDivElement>(null)
  const { disconnect } = useDisconnect()

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (popupRef.current && !popupRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  return (
    <ConnectButton.Custom>
      {({
        account,
        chain,
        openConnectModal,
        openChainModal,
        mounted,
      }) => {
        const ready = mounted
        const connected = ready && account && chain

        const { data: bnbBalance } = useBalance({
          address: account?.address as `0x${string}` | undefined,
        })

        const { data: beansBalanceRaw } = useReadContract({
          address: BEANS_ADDRESS,
          abi: erc20Abi,
          functionName: 'balanceOf',
          args: account?.address ? [account.address as `0x${string}`] : undefined,
        })

        const beansBalance = beansBalanceRaw ? Number(beansBalanceRaw) / 1e18 : 0

        const portfolio = {
          wallet: beansBalance,
          staked: 0,
          rewards: 0,
        }

        return (
          <div ref={popupRef} style={{ position: 'relative' }}>
            {(() => {
              if (!connected) {
                return (
                  <button onClick={openConnectModal} style={styles.connectButton}>
                    Connect Wallet
                  </button>
                )
              }

              if (chain.unsupported) {
                return (
                  <button onClick={openChainModal} style={styles.wrongNetwork}>
                    Wrong network
                  </button>
                )
              }

              return (
                <>
                  <button
                    onClick={() => setIsOpen(!isOpen)}
                    style={styles.accountButton}
                  >
                    {account.displayName}
                    <svg
                      width="12"
                      height="12"
                      viewBox="0 0 12 12"
                      fill="none"
                      style={{
                        marginLeft: '6px',
                        transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
                        transition: 'transform 0.2s',
                      }}
                    >
                      <path
                        d="M2.5 4.5L6 8L9.5 4.5"
                        stroke="currentColor"
                        strokeWidth="1.5"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      />
                    </svg>
                  </button>

                  {isOpen && (
                    <div style={styles.popup}>
                      <div style={styles.popupHeader}>
                        <span style={styles.popupTitle}>Account</span>
                        <button onClick={() => setIsOpen(false)} style={styles.closeButton}>
                          ✕
                        </button>
                      </div>

                      <div style={styles.addressSection}>
                        <span style={styles.label}>Wallet Address</span>
                        <div style={styles.addressRow}>
                          <span style={styles.address}>{account.displayName}</span>
                          <button
                            onClick={() => navigator.clipboard.writeText(account.address)}
                            style={styles.copyButton}
                          >
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                          </button>
                        </div>
                      </div>

                      <div style={styles.addressSection}>
                        <span style={styles.label}>BNB Balance</span>
                        <div style={styles.addressRow}>
                          <span style={styles.address}>
                            <img 
                              src="https://imagedelivery.net/GyRgSdgDhHz2WNR4fvaN-Q/6ef1a5d5-3193-4f29-1af0-48bf41735000/public" 
                              alt="BNB" 
                              style={{ width: 16, height: 16, marginRight: 6 }} 
                            />
                            {bnbBalance ? parseFloat(bnbBalance.formatted).toFixed(4) : '0.0000'} BNB
                          </span>
                        </div>
                      </div>

                      <div style={styles.portfolioSection}>
                        <span style={styles.sectionTitle}>Portfolio</span>
                        
                        <div style={styles.portfolioRow}>
                          <span style={styles.portfolioLabel}>Wallet</span>
                          <span style={styles.portfolioValue}>
                            <span style={styles.beansIcon}>🫘</span> {portfolio.wallet.toFixed(4)}
                          </span>
                        </div>
                        
                        <div style={styles.portfolioRow}>
                          <span style={styles.portfolioLabel}>Staked</span>
                          <span style={styles.portfolioValue}>
                            <span style={styles.beansIcon}>🫘</span> {portfolio.staked.toFixed(4)}
                          </span>
                        </div>
                        
                        <div style={styles.portfolioRow}>
                          <span style={styles.portfolioLabel}>Rewards</span>
                          <span style={styles.portfolioValue}>
                            <span style={styles.beansIcon}>🫘</span> {portfolio.rewards.toFixed(4)}
                          </span>
                        </div>

                        <div style={styles.portfolioRowTotal}>
                          <span style={styles.portfolioLabel}>Total</span>
                          <span style={styles.portfolioValue}>
                            <span style={styles.beansIcon}>🫘</span> {(portfolio.wallet + portfolio.staked + portfolio.rewards).toFixed(4)}
                          </span>
                        </div>
                      </div>

                      <button
                        onClick={() => {
                          setIsOpen(false)
                          disconnect()
                        }}
                        style={styles.disconnectButton}
                      >
                        Disconnect
                      </button>
                    </div>
                  )}
                </>
              )
            })()}
          </div>
        )
      }}
    </ConnectButton.Custom>
  )
}

const styles: { [key: string]: React.CSSProperties } = {
  connectButton: {
    background: 'transparent',
    border: '1px solid #333',
    color: '#fff',
    fontWeight: 500,
    padding: '8px 16px',
    borderRadius: '50px',
    cursor: 'pointer',
    fontSize: '14px',
    transition: 'all 0.2s ease',
  },
  wrongNetwork: {
    background: '#ff4444',
    border: 'none',
    color: '#fff',
    fontWeight: 500,
    padding: '8px 16px',
    borderRadius: '50px',
    cursor: 'pointer',
    fontSize: '14px',
  },
  accountButton: {
    background: '#1a1a1a',
    border: '1px solid #333',
    color: '#fff',
    fontWeight: 500,
    padding: '8px 14px',
    borderRadius: '50px',
    cursor: 'pointer',
    fontSize: '13px',
    display: 'flex',
    alignItems: 'center',
    transition: 'all 0.2s ease',
  },
  popup: {
    position: 'absolute',
    top: 'calc(100% + 10px)',
    right: 0,
    width: '300px',
    background: '#0a0a0a',
    border: '1px solid #222',
    borderRadius: '12px',
    padding: '16px',
    zIndex: 1000,
    boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
  },
  popupHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '16px',
  },
  popupTitle: {
    fontSize: '16px',
    fontWeight: 600,
    color: '#fff',
  },
  closeButton: {
    background: 'transparent',
    border: 'none',
    color: '#666',
    fontSize: '16px',
    cursor: 'pointer',
    padding: '4px',
  },
  addressSection: {
    marginBottom: '20px',
  },
  label: {
    fontSize: '12px',
    color: '#666',
    display: 'block',
    marginBottom: '6px',
  },
  addressRow: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  address: {
    fontSize: '14px',
    color: '#fff',
    fontFamily: 'monospace',
    display: 'flex',
    alignItems: 'center',
  },
  copyButton: {
    background: 'transparent',
    border: 'none',
    color: '#666',
    cursor: 'pointer',
    padding: '4px',
    display: 'flex',
    alignItems: 'center',
    transition: 'color 0.2s',
  },
  portfolioSection: {
    marginBottom: '20px',
  },
  sectionTitle: {
    fontSize: '14px',
    fontWeight: 600,
    color: '#fff',
    display: 'block',
    marginBottom: '12px',
  },
  portfolioRow: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: '8px 0',
    borderBottom: '1px solid #1a1a1a',
  },
  portfolioRowTotal: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: '12px 0 0 0',
    marginTop: '4px',
  },
  portfolioLabel: {
    fontSize: '13px',
    color: '#888',
  },
  portfolioValue: {
    fontSize: '13px',
    color: '#fff',
    display: 'flex',
    alignItems: 'center',
    gap: '4px',
  },
  beansIcon: {
    fontSize: '12px',
  },
  disconnectButton: {
    width: '100%',
    background: '#1a1a1a',
    border: '1px solid #333',
    color: '#888',
    fontWeight: 500,
    padding: '12px',
    borderRadius: '8px',
    cursor: 'pointer',
    fontSize: '14px',
    transition: 'all 0.2s ease',
  },
}

=== ./lib/SSEContext.tsx ===
'use client'

import { createContext, useContext, useEffect, useRef, useCallback, ReactNode } from 'react'
import { API_BASE } from './api'

type EventCallback = (data: unknown) => void

interface SSEContextValue {
    subscribeGlobal: (event: string, callback: EventCallback) => () => void
    subscribeUser: (event: string, callback: EventCallback) => () => void
}

const SSEContext = createContext<SSEContextValue | null>(null)

const GLOBAL_EVENTS = ['gameStarted', 'deployed', 'roundSettled']
const USER_EVENTS = ['autoMineExecuted', 'configDeactivated', 'stopped', 'claimedBNB', 'claimedBEAN', 'checkpointed']

export function SSEProvider({
    children,
    userAddress
}: {
    children: ReactNode
    userAddress?: string
}) {
    const globalListeners = useRef<Map<string, Set<EventCallback>>>(new Map())
    const userListeners = useRef<Map<string, Set<EventCallback>>>(new Map())
    const globalSource = useRef<EventSource | null>(null)
    const userSource = useRef<EventSource | null>(null)

    // ONE global connection
    useEffect(() => {
        const source = new EventSource(`${API_BASE}/api/events/rounds`)
        globalSource.current = source

        GLOBAL_EVENTS.forEach(event => {
            source.addEventListener(event, (e: MessageEvent) => {
                try {
                    const data = JSON.parse(e.data)
                    globalListeners.current.get(event)?.forEach(cb => cb(data))
                } catch {
                    globalListeners.current.get(event)?.forEach(cb => cb(e.data))
                }
            })
        })

        source.onerror = () => {
            console.warn('[SSE] Global connection error, will auto-reconnect')
        }

        return () => {
            source.close()
            globalSource.current = null
        }
    }, [])

    // ONE user connection (when wallet connected)
    useEffect(() => {
        if (!userAddress) {
            userSource.current?.close()
            userSource.current = null
            return
        }

        const source = new EventSource(`${API_BASE}/api/user/${userAddress}/events`)
        userSource.current = source

        USER_EVENTS.forEach(event => {
            source.addEventListener(event, (e: MessageEvent) => {
                try {
                    const data = JSON.parse(e.data)
                    userListeners.current.get(event)?.forEach(cb => cb(data))
                } catch {
                    userListeners.current.get(event)?.forEach(cb => cb(e.data))
                }
            })
        })

        source.onerror = () => {
            console.warn('[SSE] User connection error, will auto-reconnect')
        }

        return () => {
            source.close()
            userSource.current = null
        }
    }, [userAddress])

    const subscribeGlobal = useCallback((event: string, callback: EventCallback) => {
        if (!globalListeners.current.has(event)) {
            globalListeners.current.set(event, new Set())
        }
        globalListeners.current.get(event)!.add(callback)

        return () => {
            globalListeners.current.get(event)?.delete(callback)
        }
    }, [])

    const subscribeUser = useCallback((event: string, callback: EventCallback) => {
        if (!userListeners.current.has(event)) {
            userListeners.current.set(event, new Set())
        }
        userListeners.current.get(event)!.add(callback)

        return () => {
            userListeners.current.get(event)?.delete(callback)
        }
    }, [])

    return (
        <SSEContext.Provider value={{ subscribeGlobal, subscribeUser }}>
            {children}
        </SSEContext.Provider>
    )
}

export function useSSE() {
    const context = useContext(SSEContext)
    if (!context) throw new Error('useSSE must be used within SSEProvider')
    return context
}

=== ./lib/abis/AutoMiner.json ===
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_gridMining",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_executor",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "_executorFeeBps",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "AlreadyPlayedThisRound",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ConfigAlreadyActive",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ConfigNotActive",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "DuplicateBlock",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "FeeTooHigh",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GameNotStarted",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InsufficientDeposit",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidBlockCount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidBlockId",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidDeposit",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidFixedBlocks",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidNumBlocks",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidNumRounds",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidStrategy",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "NoFeesToCollect",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "NotExecutor",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "RoundLimitReached",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "RoundNotActive",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "StrategyNotFound",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ZeroAddress",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "total",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "successful",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "failed",
        "type": "uint256"
      }
    ],
    "name": "BatchExecuted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "roundsCompleted",
        "type": "uint256"
      }
    ],
    "name": "ConfigDeactivated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "numBlocks",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountPerBlock",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "numRounds",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "depositAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      }
    ],
    "name": "ConfigUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": false,
        "internalType": "uint8[]",
        "name": "blocks",
        "type": "uint8[]"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalDeployed",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "fee",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "roundsExecuted",
        "type": "uint256"
      }
    ],
    "name": "ExecutedFor",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldFeeBps",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newFeeBps",
        "type": "uint256"
      }
    ],
    "name": "ExecutorFeeBpsUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "oldExecutor",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newExecutor",
        "type": "address"
      }
    ],
    "name": "ExecutorUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "executor",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "FeesCollected",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "oldGridMining",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newGridMining",
        "type": "address"
      }
    ],
    "name": "GridMiningUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "refundAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "roundsCompleted",
        "type": "uint256"
      }
    ],
    "name": "Stopped",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "fixedBlocks",
        "type": "uint8"
      }
    ],
    "name": "StrategyAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      }
    ],
    "name": "StrategyUpdated",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "BPS_DENOMINATOR",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "GRID_SIZE",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MAX_FEE_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "accumulatedFees",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "activeUserIndex",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "activeUsers",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "fixedBlocks",
        "type": "uint8"
      }
    ],
    "name": "addStrategy",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "canExecute",
    "outputs": [
      {
        "internalType": "bool",
        "name": "executable",
        "type": "bool"
      },
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "collectFees",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "configs",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      },
      {
        "internalType": "uint8",
        "name": "numBlocks",
        "type": "uint8"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      },
      {
        "internalType": "uint16",
        "name": "executorFeeBps",
        "type": "uint16"
      },
      {
        "internalType": "uint128",
        "name": "amountPerBlock",
        "type": "uint128"
      },
      {
        "internalType": "uint64",
        "name": "numRounds",
        "type": "uint64"
      },
      {
        "internalType": "uint64",
        "name": "roundsExecuted",
        "type": "uint64"
      },
      {
        "internalType": "uint128",
        "name": "depositAmount",
        "type": "uint128"
      },
      {
        "internalType": "uint32",
        "name": "depositTimestamp",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "users",
        "type": "address[]"
      },
      {
        "internalType": "uint8[][]",
        "name": "blocks",
        "type": "uint8[][]"
      }
    ],
    "name": "executeBatch",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "successCount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "failCount",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "uint8[]",
        "name": "blocks",
        "type": "uint8[]"
      }
    ],
    "name": "executeFor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "uint8[]",
        "name": "blocks",
        "type": "uint8[]"
      }
    ],
    "name": "executeForInternal",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "executor",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "executorFeeBps",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getActiveUserCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "offset",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "limit",
        "type": "uint256"
      }
    ],
    "name": "getActiveUsers",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "users",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getConfigProgress",
    "outputs": [
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      },
      {
        "internalType": "uint256",
        "name": "numRounds",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "roundsExecuted",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "roundsRemaining",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "percentComplete",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getRoundsRemaining",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      }
    ],
    "name": "getStrategy",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "fixedBlocks",
        "type": "uint8"
      },
      {
        "internalType": "bool",
        "name": "exists",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getUserState",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint8",
            "name": "strategyId",
            "type": "uint8"
          },
          {
            "internalType": "uint8",
            "name": "numBlocks",
            "type": "uint8"
          },
          {
            "internalType": "bool",
            "name": "active",
            "type": "bool"
          },
          {
            "internalType": "uint16",
            "name": "executorFeeBps",
            "type": "uint16"
          },
          {
            "internalType": "uint128",
            "name": "amountPerBlock",
            "type": "uint128"
          },
          {
            "internalType": "uint64",
            "name": "numRounds",
            "type": "uint64"
          },
          {
            "internalType": "uint64",
            "name": "roundsExecuted",
            "type": "uint64"
          },
          {
            "internalType": "uint128",
            "name": "depositAmount",
            "type": "uint128"
          },
          {
            "internalType": "uint32",
            "name": "depositTimestamp",
            "type": "uint32"
          }
        ],
        "internalType": "struct AutoMiner.AutoConfig",
        "name": "config",
        "type": "tuple"
      },
      {
        "internalType": "uint64",
        "name": "lastRound",
        "type": "uint64"
      },
      {
        "internalType": "uint256",
        "name": "costPerRound",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "roundsRemaining",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalRefundable",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "gridMining",
    "outputs": [
      {
        "internalType": "contract IGridMining",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "lastRoundPlayed",
    "outputs": [
      {
        "internalType": "uint64",
        "name": "",
        "type": "uint64"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "minDeploy",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      },
      {
        "internalType": "uint256",
        "name": "numRounds",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "numBlocks",
        "type": "uint8"
      }
    ],
    "name": "setConfig",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_executor",
        "type": "address"
      }
    ],
    "name": "setExecutor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_feeBps",
        "type": "uint256"
      }
    ],
    "name": "setExecutorFeeBps",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_gridMining",
        "type": "address"
      }
    ],
    "name": "setGridMining",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "strategyId",
        "type": "uint8"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      }
    ],
    "name": "setStrategyActive",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "stop",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "name": "strategies",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "fixedBlocks",
        "type": "uint8"
      },
      {
        "internalType": "bool",
        "name": "exists",
        "type": "bool"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "strategyCount",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]

=== ./lib/abis/Bean.json ===
[
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ECDSAInvalidSignature",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "length",
        "type": "uint256"
      }
    ],
    "name": "ECDSAInvalidSignatureLength",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "ECDSAInvalidSignatureS",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allowance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientAllowance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "balance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientBalance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "approver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidApprover",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "receiver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidReceiver",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSpender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      }
    ],
    "name": "ERC2612ExpiredSignature",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "signer",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "ERC2612InvalidSigner",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ExceedsMaxSupply",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "currentNonce",
        "type": "uint256"
      }
    ],
    "name": "InvalidAccountNonce",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidShortString",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "MinterAlreadyFrozen",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "NotMinter",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "str",
        "type": "string"
      }
    ],
    "name": "StringTooLong",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "TWAPNotReady",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ZeroAddress",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [],
    "name": "EIP712DomainChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "minter",
        "type": "address"
      }
    ],
    "name": "MinterFrozen",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "oldMinter",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newMinter",
        "type": "address"
      }
    ],
    "name": "MinterUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "oldPair",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newPair",
        "type": "address"
      }
    ],
    "name": "PairUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MAX_SUPPLY",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "burn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "calculateAverageReserves",
    "outputs": [
      {
        "internalType": "uint112",
        "name": "avgReserve0",
        "type": "uint112"
      },
      {
        "internalType": "uint112",
        "name": "avgReserve1",
        "type": "uint112"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "currentSnapshotIndex",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "eip712Domain",
    "outputs": [
      {
        "internalType": "bytes1",
        "name": "fields",
        "type": "bytes1"
      },
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "version",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "chainId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "verifyingContract",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "salt",
        "type": "bytes32"
      },
      {
        "internalType": "uint256[]",
        "name": "extensions",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "freezeMinter",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getPriceDeviation",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "spotPrice",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "twapPrice",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deviationBps",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserveHistory",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint112",
            "name": "reserve0",
            "type": "uint112"
          },
          {
            "internalType": "uint112",
            "name": "reserve1",
            "type": "uint112"
          },
          {
            "internalType": "uint32",
            "name": "blockNumber",
            "type": "uint32"
          }
        ],
        "internalType": "struct Bean.ReserveSnapshot[5]",
        "name": "snapshots",
        "type": "tuple[5]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "bnbAmount",
        "type": "uint256"
      }
    ],
    "name": "getTWAPAmountOut",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "expectedBEAN",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "isTWAPReady",
    "outputs": [
      {
        "internalType": "bool",
        "name": "ready",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "minter",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "minterFrozen",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "pair",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "reserveHistory",
    "outputs": [
      {
        "internalType": "uint112",
        "name": "reserve0",
        "type": "uint112"
      },
      {
        "internalType": "uint112",
        "name": "reserve1",
        "type": "uint112"
      },
      {
        "internalType": "uint32",
        "name": "blockNumber",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "router",
    "outputs": [
      {
        "internalType": "contract IUniswapV2Router02",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_minter",
        "type": "address"
      }
    ],
    "name": "setMinter",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "updateReserveSnapshot",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]

=== ./lib/abis/ERC20.json ===
[
  {
    "inputs": [{"name": "account", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{"name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{"name": "", "type": "uint8"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{"name": "", "type": "string"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{"name": "", "type": "string"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {"name": "to", "type": "address"},
      {"name": "amount", "type": "uint256"}
    ],
    "name": "transfer",
    "outputs": [{"name": "", "type": "bool"}],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {"name": "spender", "type": "address"},
      {"name": "amount", "type": "uint256"}
    ],
    "name": "approve",
    "outputs": [{"name": "", "type": "bool"}],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {"name": "owner", "type": "address"},
      {"name": "spender", "type": "address"}
    ],
    "name": "allowance",
    "outputs": [{"name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {"name": "from", "type": "address"},
      {"name": "to", "type": "address"},
      {"name": "amount", "type": "uint256"}
    ],
    "name": "transferFrom",
    "outputs": [{"name": "", "type": "bool"}],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "name": "from", "type": "address"},
      {"indexed": true, "name": "to", "type": "address"},
      {"indexed": false, "name": "value", "type": "uint256"}
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "name": "owner", "type": "address"},
      {"indexed": true, "name": "spender", "type": "address"},
      {"indexed": false, "name": "value", "type": "uint256"}
    ],
    "name": "Approval",
    "type": "event"
  }
]

=== ./lib/abis/GridMining.json ===
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_vrfCoordinator",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_bean",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_treasury",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_feeCollector",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "AlreadyCheckpointed",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "AlreadyDeployedThisRound",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GameAlreadyStarted",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GameNotStarted",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InsufficientDeployAmount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidBlockId",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidVRFRequest",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "MaxSupplyReached",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "NoBlocksSelected",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "NotAutoMiner",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "NothingToClaim",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "have",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "want",
        "type": "address"
      }
    ],
    "name": "OnlyCoordinatorCanFulfill",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "have",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "coordinator",
        "type": "address"
      }
    ],
    "name": "OnlyOwnerOrCoordinator",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "RoundAlreadySettled",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "RoundNotActive",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "RoundNotEnded",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "RoundNotSettled",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "TransferFailed",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "VRFAlreadyRequested",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "VRFNotConfigured",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ZeroAddress",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "oldAutoMiner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newAutoMiner",
        "type": "address"
      }
    ],
    "name": "AutoMinerUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "bnbReward",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "beanReward",
        "type": "uint256"
      }
    ],
    "name": "Checkpointed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "gross",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "fee",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "net",
        "type": "uint256"
      }
    ],
    "name": "ClaimedBEAN",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "ClaimedBNB",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "vrfCoordinator",
        "type": "address"
      }
    ],
    "name": "CoordinatorSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountPerBlock",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "blockMask",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalAmount",
        "type": "uint256"
      }
    ],
    "name": "Deployed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "executor",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountPerBlock",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "blockMask",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalAmount",
        "type": "uint256"
      }
    ],
    "name": "DeployedFor",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "startTime",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "endTime",
        "type": "uint256"
      }
    ],
    "name": "GameStarted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferRequested",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "vrfRequestId",
        "type": "uint256"
      }
    ],
    "name": "ResetRequested",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "winningBlock",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "topMiner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalWinnings",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "topMinerReward",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "motherlodeAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "isSplit",
        "type": "bool"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "topMinerSeed",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "winnersDeployed",
        "type": "uint256"
      }
    ],
    "name": "RoundSettled",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "ADMIN_FEE_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "BPS_DENOMINATOR",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "GRID_SIZE",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MAX_SUPPLY",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MIN_DEPLOY",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MOTHERLODE_ACCUMULATION",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MOTHERLODE_CHANCE",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "ONE_BEAN",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "REFINING_FEE_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "ROUND_DURATION",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "VAULT_FEE_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "accRefiningPerUnclaimed",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "acceptOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "autoMiner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bean",
    "outputs": [
      {
        "internalType": "contract IBean",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      }
    ],
    "name": "checkpoint",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimBEAN",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimBNB",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "currentRoundId",
    "outputs": [
      {
        "internalType": "uint64",
        "name": "",
        "type": "uint64"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint8[]",
        "name": "blockIds",
        "type": "uint8[]"
      }
    ],
    "name": "deploy",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "uint8[]",
        "name": "blockIds",
        "type": "uint8[]"
      }
    ],
    "name": "deployFor",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "feeCollector",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "gameStarted",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getCurrentRoundInfo",
    "outputs": [
      {
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "internalType": "uint256",
        "name": "startTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalDeployed",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "timeRemaining",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "isActive",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      },
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getMinerInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "deployedMask",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountPerBlock",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "checkpointed",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getPendingBEAN",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "gross",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "fee",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "net",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getPendingBNB",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      }
    ],
    "name": "getRound",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "startTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalDeployed",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalWinnings",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "winningBlock",
        "type": "uint8"
      },
      {
        "internalType": "address",
        "name": "topMiner",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "topMinerReward",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "motherlodeAmount",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "settled",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint64",
        "name": "roundId",
        "type": "uint64"
      }
    ],
    "name": "getRoundDeployed",
    "outputs": [
      {
        "internalType": "uint256[25]",
        "name": "",
        "type": "uint256[25]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getTotalPendingRewards",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "pendingBNB",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "pendingUnrefinedBEAN",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "pendingRefinedBEAN",
        "type": "uint256"
      },
      {
        "internalType": "uint64",
        "name": "uncheckpointedRound",
        "type": "uint64"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint64",
        "name": "",
        "type": "uint64"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "miners",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "deployedMask",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountPerBlock",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "checkpointed",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "motherlodePool",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "requestId",
        "type": "uint256"
      },
      {
        "internalType": "uint256[]",
        "name": "randomWords",
        "type": "uint256[]"
      }
    ],
    "name": "rawFulfillRandomWords",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "reset",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint64",
        "name": "",
        "type": "uint64"
      }
    ],
    "name": "rounds",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "startTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "endTime",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalDeployed",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalWinnings",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "winnersDeployed",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "winningBlock",
        "type": "uint8"
      },
      {
        "internalType": "address",
        "name": "topMiner",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "topMinerReward",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "motherlodeAmount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "vrfRequestId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "topMinerSeed",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "settled",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "s_vrfCoordinator",
    "outputs": [
      {
        "internalType": "contract IVRFCoordinatorV2Plus",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_autoMiner",
        "type": "address"
      }
    ],
    "name": "setAutoMiner",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_vrfCoordinator",
        "type": "address"
      }
    ],
    "name": "setCoordinator",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_feeCollector",
        "type": "address"
      }
    ],
    "name": "setFeeCollector",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_treasury",
        "type": "address"
      }
    ],
    "name": "setTreasury",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_subscriptionId",
        "type": "uint256"
      },
      {
        "internalType": "bytes32",
        "name": "_keyHash",
        "type": "bytes32"
      },
      {
        "internalType": "uint32",
        "name": "_callbackGasLimit",
        "type": "uint32"
      },
      {
        "internalType": "uint16",
        "name": "_requestConfirmations",
        "type": "uint16"
      }
    ],
    "name": "setVRFConfig",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "startFirstRound",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalMinted",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalUnclaimed",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "treasury",
    "outputs": [
      {
        "internalType": "contract ITreasury",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userLastRound",
    "outputs": [
      {
        "internalType": "uint64",
        "name": "",
        "type": "uint64"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userRefinedBEAN",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userRefiningDebt",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userUnclaimedBEAN",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "userUnclaimedBNB",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "vrfCallbackGasLimit",
    "outputs": [
      {
        "internalType": "uint32",
        "name": "",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "vrfKeyHash",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "vrfNumWords",
    "outputs": [
      {
        "internalType": "uint32",
        "name": "",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "vrfRequestConfirmations",
    "outputs": [
      {
        "internalType": "uint16",
        "name": "",
        "type": "uint16"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "vrfRequestToRound",
    "outputs": [
      {
        "internalType": "uint64",
        "name": "",
        "type": "uint64"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "vrfSubscriptionId",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]

=== ./lib/abis/Treasury.json ===
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_bean",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "_buybackThreshold",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "BelowThreshold",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "BuybackFailed",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "OnlyGridMining",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "SlippageTooHigh",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "TWAPNotReady",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ZeroAddress",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "bnbSpent",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "beanReceived",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "beanBurned",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "beanToStakers",
        "type": "uint256"
      }
    ],
    "name": "BuybackExecuted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldSlippage",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newSlippage",
        "type": "uint256"
      }
    ],
    "name": "SlippageUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldThreshold",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newThreshold",
        "type": "uint256"
      }
    ],
    "name": "ThresholdUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalVaulted",
        "type": "uint256"
      }
    ],
    "name": "VaultReceived",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "BPS_DENOMINATOR",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "BURY_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "DEFAULT_SLIPPAGE_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MAX_SLIPPAGE_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "STAKER_BPS",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "bean",
    "outputs": [
      {
        "internalType": "contract IBean",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "buybackThreshold",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "canExecuteBuyback",
    "outputs": [
      {
        "internalType": "bool",
        "name": "canExecute",
        "type": "bool"
      },
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "executeBuyback",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getStats",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "_vaultedBNB",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_totalBurned",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_totalDistributedToStakers",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_totalBuybacks",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "gridMining",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "receiveVault",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "router",
    "outputs": [
      {
        "internalType": "contract IUniswapV2Router02",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_threshold",
        "type": "uint256"
      }
    ],
    "name": "setBuybackThreshold",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_gridMining",
        "type": "address"
      }
    ],
    "name": "setGridMining",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_slippageBps",
        "type": "uint256"
      }
    ],
    "name": "setSlippage",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_staking",
        "type": "address"
      }
    ],
    "name": "setStaking",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "slippageBps",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "staking",
    "outputs": [
      {
        "internalType": "contract IStaking",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalBurned",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalBuybacks",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalDistributedToStakers",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "vaultedBNB",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]

=== ./lib/api.ts ===
export const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export async function apiFetch<T>(path: string): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`);
  if (!res.ok) throw new Error(`API ${path}: ${res.status}`);
  return res.json();
}

/**
 * Subscribe to a backend SSE stream.
 * @param path - SSE endpoint path
 * @param onEvent - callback receiving (eventName, parsedData)
 * @param events - event names to listen for (defaults to global round events)
 * Returns a cleanup function to close the connection.
 */
export function sseSubscribe(
  path: string,
  onEvent: (event: string, data: unknown) => void,
  events: string[] = ['gameStarted', 'deployed', 'roundSettled'],
): () => void {
  const source = new EventSource(`${API_BASE}${path}`);

  const handleEvent = (type: string) => (e: MessageEvent) => {
    try {
      onEvent(type, JSON.parse(e.data));
    } catch {
      onEvent(type, e.data);
    }
  };

  events.forEach((evt) => source.addEventListener(evt, handleEvent(evt)));

  source.onerror = () => {
    // EventSource auto-reconnects; nothing extra needed
  };

  return () => source.close();
}

=== ./lib/contracts.ts ===
import GridMiningABI from './abis/GridMining.json'
import AutoMinerABI from './abis/AutoMiner.json'
import BeanABI from './abis/Bean.json'
import TreasuryABI from './abis/Treasury.json'
import ERC20ABI from './abis/ERC20.json'

export const CONTRACTS = {
  GridMining: {
    address: '0x3fd29fd722433c0aAd30B2B62C95d6A457A87c7e' as `0x${string}`,
    abi: GridMiningABI,
  },
  Bean: {
    address: '0xBe4764ccE14B7BF478597AA00F5f6A5D42547925' as `0x${string}`,
    abi: BeanABI,
  },
  AutoMiner: {
    address: '0x442714CcFf3f0C851A16cA9B3733cd58951389e1' as `0x${string}`,
    abi: AutoMinerABI,
  },
  Treasury: {
    address: '0x0093DB20543d17F294F58432D08c4FA47C70dfe9' as `0x${string}`,
    abi: TreasuryABI,
  },
  BEANS: {
    address: '0x000Ae314E2A2172a039B26378814C252734f556A' as `0x${string}`,
    abi: ERC20ABI,
  },
  LP: {
    address: '0x7e58f160b5b77b8b24cd9900c09a3e730215ac47' as `0x${string}`,
  },
} as const

// Below values are used by frontend validations to avoid users submitting tx's that will revert due to contract limits.
// Make sure they reflect the true contract values.
export const MIN_DEPLOY_PER_BLOCK = 0.00001 // BNB
export const EXECUTOR_FEE_BPS = 100 // 1% AutoMiner executor fee

=== ./lib/providers.tsx ===
'use client'

import { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider, useAccount } from 'wagmi'
import { config } from '@/lib/wagmi'
import { useState } from 'react'
import { SSEProvider } from './SSEContext'

import '@rainbow-me/rainbowkit/styles.css'

function SSEWrapper({ children }: { children: React.ReactNode }) {
  const { address } = useAccount()
  return <SSEProvider userAddress={address}>{children}</SSEProvider>
}

export function Web3Provider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient())

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider
          theme={darkTheme({
            accentColor: '#F0B90B',
            accentColorForeground: '#000',
            borderRadius: 'medium',
            fontStack: 'system',
            overlayBlur: 'small',
          })}
          modalSize="compact"
        >
          <SSEWrapper>{children}</SSEWrapper>
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  )
}

=== ./lib/wagmi.ts ===
'use client'

import { getDefaultConfig } from '@rainbow-me/rainbowkit'
import { bsc, bscTestnet } from 'wagmi/chains'

export const config = getDefaultConfig({
  appName: 'BEANS Protocol',
  projectId: '666aa4c4e1ee459d4697a07bcf2f1ec6',
  chains: [bsc, bscTestnet],
  ssr: true,
})

=== ./package.json ===
{
  "name": "beans-protocol",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@rainbow-me/rainbowkit": "^2.1.2",
    "@tanstack/react-query": "^5.28.4",
    "next": "14.2.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "viem": "^2.9.20",
    "wagmi": "^2.8.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "typescript": "^5"
  }
}

=== ./tsconfig.json ===
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

